# 挑战程序设计竞赛



>  **纸上得来终觉浅，绝知此事要躬行**



## 第1章 蓄势待发：准备篇

**常见的评测结果**

| 结果                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| Accepted, AC               | 单点测试，没通过一组数据，就会返回一个Accepted；多点测试只有通过所有的数据之后，才会返回一个Accepted。 |
| Compile Error, CE          | 代码没有通过编译，看本地编译器能不能通过代码，修改之后再提交。 |
| Wrong Answer, WA           | 代码有漏洞或者算法就是错的。                                 |
| Time Limit Exceeded, TLE   | 运行时间超过允许上限。死循环的情况最常见                     |
| Running Error, RE          | 造成这一错误的可能性很多：非法访问内存，浮点错误，递归爆栈等。 |
| Memory Limit Exceeded, MLE | 一般数组太大会导致这个问题                                   |
| Presentation Error, PE     | 最接近Accepted的错误，一般由多输出空格或者换行导致。         |
| Output Limit Exceeded, OLE | 一般由输出了大量调试信息或者特殊数据导致死循环输出导致。     |



### 1.5 以高效的算法为目标

#### 由数据范围反推算法复杂度以及算法内容

<img src="https://img-blog.csdnimg.cn/62d4053ccdbc43ffb28d548b78eb56d7.png" alt="图片来自acwing闫雪灿" style="zoom: 67%;" />




### 1.6 轻松热身

#### [有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

（1）BF暴力枚举，时间复杂度O(n<sup>3</sup>) n<=1000 超时

（2）排序+ 二分查找，时间复杂度O(n<sup>2</sup>logn之间)

将数据排好序之后，利用两个指针i，j指向三角形的两条边，此时由于数据已经有序，那么只需要找到<(nums[i] + nums[j])的最后一个元素即可，假设找到的数组元素的下标为k，那么nums[j+1....k]之间的元素，都可以和nums[i]、nums[j]构成三角形

```c++
class Solution {
    vector<int> nums;
public:

    int triangleNumber(vector<int>& nums) {
        this->nums = nums;
        int n = nums.size(), res = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; i++){
            for (int j = i+1; j < n; j++){
                int low = j+1, high = n, target = nums[i] + nums[j];
                //二分查找>=target的第一个元素所在的位置, low-1就是<target的最大下标
                while(low < high){
                    int mid = (low + high) / 2;
                    if (nums[mid] >= target){
                        high = mid;
                    }else
                        low = mid+1;
                }
                if (low-1 > j)  //low-1就是<target的元素的最后一个位置
                    res += low-j-1;
            }
        }
        return res;
    }
};

class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int res = 0, n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; i++){
            for (int j = i+1; j < n; j++){
                //返回>=nums[i]+nums[j]的以一个位置
                int k = lower_bound(nums.begin() + j, nums.end(), nums[i] + nums[j]) - nums.begin();
                if (k > j)
                    res += k-j-1;
            }
        }
        return res;
    }
};
```

> 一顿操作猛如虎，提交击败5%



（3）排序 + 双指针

nums[i]固定，随着nums[j]的增加，nums[k]也会增加，固定i让j和k右移，每次k移动到最右边

**算法的时间复杂度O(n<sup>2</sup>)，对于第二个for循环并不是每次k都会从j+1移动到n**

```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size(), res = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n-2; i++){
            for (int j = i+1, k = i+2; j < n-1; j++){
                while(k < n && nums[k] < nums[i] + nums[j]) k++;
                res += max(k-j-1, 0);
            }
        }
        return res;
    }
};
```



[1503. 所有蚂蚁掉下来前的最后一刻](https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/)

```c++
class Solution {
public:
    int getLastMoment(int n, vector<int>& left, vector<int>& right) {
        int res = left.size() > 0 ? *max_element(left.begin(), left.end()) : 0;
        for (int i : right) 
            res = max(res, n-i);
        return res;   
    }
};
```

tag:脑筋急转弯



#### [两数之和](https://leetcode.cn/problems/two-sum/)

（1）暴力搜索，算法的时间复杂度O(n<sup>2</sup>)

（2）哈希表，算法的时间复杂度O(n)

利用一个哈希表来存储数组中的值和对应的下标，这里需要注意的是必须是数组中两个不同的下标，所以需要在判断条件上额外添加

```c++
i != mp[target - nums[i])]
```



#### [三数之和](https://leetcode.cn/problems/3sum/)

n = 3000，用暴力可能会超时，可以根据题意添加一些条件来减少不必要的判断

（1）暴力，算法的时间复杂度O(n<sup>3</sup>)，**超时**

（2）排序 + 二分查找，算法的时间复杂度O(n<sup>2</sup>log<sub>2</sub>n)

（3）**排序 + 双指针 + 优化**   	算法的时间复杂度 < O(n<sup>2</sup>)

（3）排序 + 哈希表 + 优化	同上

（4）DFS	（只是为了锻炼代码，**超时**）



#### [四数之和](https://leetcode.cn/problems/4sum/)



****





## 第2章 初出茅庐-初级篇

### 2.1 最基础的“穷竭搜索”

#### 2.1.1 递归函数

[斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

（1）递归

```c++
class Solution {
public:
    int fib(int n) {
        if (n < 2)  return n;
        return fib(n-1) + fib(n-2);
    }
};
```

时间复杂度$O(2^n)$



（2）记忆化搜索

```
class Solution {
    const int mod = 1e9 + 7;
    int nums[110];
public:
    int fib(int n) {
        memset(nums, -1, sizeof nums);
        return getElement(n);
    }

    int getElement(int n){
        if (n < 2)
            return n;
        else if (nums[n] != -1)
            return nums[n];
        return nums[n] = (getElement(n-1) + getElement(n-2)) % mod;
    }
};
```

时间复杂度$O(n)$，和上面的递归相比如果当前fib(n)已经计算过，可以直接返回元素值，减少了重复计算



（3）递推

```c++
class Solution {
public:
    int fib(int n) {
        if (n < 2)  return n;
        int res = 0, a = 0, b = 1, mod = 1e9+7;
        for (int i = 2; i <= n; i++){
            res = (a + b) % mod;
            a = b;
            b = res;
        }
        return res;
    }
};
```

时间复杂度$O(n)$



#### 2.1.2 栈

**stack的常用解法详解**

**stack，翻译为栈，是STL中一个后进先出的容器**

##### 1 stack的定义

```c++
#include <stack>
using namespace std;

stack<typename> name;
```



##### 2 stack容器内元素的访问

**由于stack本身就是一种后进先出的数据结构，在STL的stack中只能通过top()来访问栈顶元素** 



##### 3 stack常用函数实例解析

###### （1）push()

push(x)，将x入栈，时间复杂度O(1)

###### （2）top()

top()访问栈顶元素，时间复杂度O(1)

###### （3）pop()

pop()可以弹出栈顶元素，时间复杂度O(1)

###### （4）empty()

empty()可以检测stack()内是否为空，为空则返回true，时间复杂度O(1)

###### （5）size()

size()返回stack内元素的个数，时间复杂度O(1)



##### 4 stack的常见用途

stack用来模拟实现一些递归，防止程序对栈的内存限制从而导致程序运行出错



#### 2.1.3 队列

**queue的常用解法详解**

**queue翻译为队列，在STL中则是实现了一个先进先出的容器**



##### 1 queue的定义

```c++
#include<queue>
using namespace std;

queue<typename> name;
```

##### 2 queue容器内元素的访问

**由于queue是一种先进先出的限制性数据结构，**
**因此在queue中只能通过front来访问队首元素，back来访问队尾元素**



##### 3 queue常用函数解析

##### （1）push()

push(x)将x入队，时间复杂度O(1)

##### （2）front()、back() 

front()获得队首元素，back()获取队尾元素，时间复杂度O(1)

##### （3）pop() 

令队首元素出队，时间复杂度O(1)

##### （4）empty()

empty检测queue是否为空，为空返回true，不空返回false，时间复杂度O(1) 

##### （5）size()

size()返回queue内元素的个数，时间复杂度O(1) 



##### 4 queue的常见用途

**树的层次遍历、图的广度优先遍历都会用到queue** 



##### 双端队列deque

```c++
#include <deque>
using namespace std;
```

**双端队列可以在对头队尾两端进行插入和删除**

###### 1 push_back()、push_front()

push_back()、push_front()分别在队尾、队头进行插入

###### 2 pop_back()、pop_front() 

pop_back()、pop_front()分别将队尾元素和队头元素弹出 



##### 单调队列

**Acwing 窗口内的最小值和最大值**

1 3 -1 -3 5 3 6 7
**(1)使用普通的队列**

让队列的大小为k，每扫描到一个数就将这个数加入到队列中
再在队列中扫描一遍，获得最大值和最小值，算法的时间复杂度O(n * k)

**(2)使用单调队列**
**首先解决最小值** 
对1 3 -1而言，1、3都要比-1小并且在-1前面，也就是说窗口内的1、3永远不会成为最小值，所以可以将1、3删除
只剩下-1。对-3而言，它比窗口内的-1要小，所以-1不会成为最小值，-1可以删除....
**最后删除前面这些>nums[i]的数之后，整个窗口内的数成一个递增有序的状态**
**始终维持队列中的元素递增(可以存在重复元素)**
在这里需要注意的是，当nums[i] < nums[q.back()]时，我们**应该将队尾元素出队**，所以使用的是**双端队列** 
当遍历到某个元素时，我们就可以用过单调队列来寻找它的最小值(单调队列的队头元素)

```c++
#include <iostream>
#include <deque>
using namespace std;

deque<int> dq;
const int N = 1000010;
int nums[N];

int main(){
    int n, k;
    cin>>n>>k;
    for (int i = 0; i < n; i++){
        cin>>nums[i];
    }
    for (int i = 0; i < n; i++){
        if (dq.size() && i-dq.front()+1 > k)  dq.pop_front(); //只保留i和i之前的k个元素
        while(dq.size() && nums[dq.back()] > nums[i]){//维护一个单调递增的双向队列
            dq.pop_back();
        }
        dq.push_back(i);
        if (i >= k-1)   cout<<nums[dq.front()]<<" ";
    }
    cout<<endl;
    
    dq.clear();
    for (int i = 0; i < n; i++){
        if (dq.size() && i-dq.front()+1 > k)  dq.pop_front(); //只保留i和i之前的k个元素
        while(dq.size() && nums[dq.back()] < nums[i]){//维护一个单调递减的双向队列
            dq.pop_back();
        }
        dq.push_back(i);
        if (i >= k-1)   cout<<nums[dq.front()]<<" ";
    }
    return 0;
}
```



##### priority_queue的常用解法详解

**priority_queue又称为优先队列，其底层是用堆(heap)来实现的**
**在优先队列中，队首元素是当前队列中优先级最高的一个**



###### 1 priority_queue的定义

```c++
#include <queue> 
using namespace std;

priority_queue<typename> name;
```



###### 2 priority_queue容器内元素的访问

和队列不一样，**优先队列没有front()、back()函数，**
**只能通过top()函数来访问队首元素(堆顶元素)，也就是优先级最高的元素**



###### 3 priority_queue常用函数实例解析

**（1）push()**

push(x)将x入队，时间复杂度O(log N)，其中N为当前优先队列中元素的个数

**（2）top()**

top()可以获得队首(堆顶)元素，时间复杂度O(log N)

**（3）pop()**

pop()令队首元素出队，时间复杂度O(log N)

**（4）empty()**

empty()检测priority_queue是否为空，为空返回true，不空返回false，时间复杂度O(1) 

**（5）size()**

size()返回priority_queue内元素的个数，时间复杂度O(1) 



###### 4 priority_queue内元素优先级的设置(重点)



**(1) 基本数据类型的优先级设置**

在这里指的基本数据类型是int, char, double可以直接使用的数据类型
**默认是数值越大优先级越高(大根堆)** 

```c++
priority_queue<int> q; 
priority_queue<int, vector<int>, less<int>> q;
/*
int表示priority_queue中存储元素的类型，vector<int>是承载数据结构堆(heap)底层容器 
less<int>表示数字越大优先级越高
greater<int>表示数据越小优先级越高
*/
```



**(2)结构体的优先级的设置** 

```c++
struct cmp{
	bool operator()(ListNode *a, ListNode *b){
		return a->val > b->val;
	}
};
//优先队列中cmp函数的效果和sort中cmp的效果刚好相反 
```

**notes:**
**如果结构体中的数据较为庞大(例如出现字符串或数组)，可以使用引用来提高效率（在Leetcode中常用）**
**此时在参数中加上"const"、"&"**

```c++
struct cmp{
    bool operator()(const ListNode *a, const ListNode *b){
        return a->val > b->val;
    }
}; 
```

**优先队列相关题目：**

###### [743网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

###### [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct cmp{
        bool operator()(ListNode* a, ListNode *b){
            return a->val > b->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, cmp> pq;
        for (ListNode* list : lists){    //初始时将每个链表的头结点入队
            if (list)   pq.push(list);
        }

        ListNode *dummy = new ListNode();
        ListNode *r = dummy;
        while(pq.size()){
            ListNode *cur = pq.top(); pq.pop();
            r->next = cur, r = cur;
            if (cur->next)  pq.push(cur->next);
        }
        r->next = nullptr;
        return dummy->next;
    }
};
```

****



#### 2.1.4 深度优先搜索

[深度优先搜索图文学](https://leetcode.cn/leetbook/detail/dfs/)





#### 2.1.5 广度优先搜索

[广度优先搜索图文学](https://leetcode.cn/leetbook/detail/bfs/)



#### 2.1.6 特殊状态的枚举

[全排列](https://leetcode.cn/problems/permutations/)

[全排列II](https://leetcode.cn/problems/permutations-ii/)



#### 2.1.7 剪枝



### 2.2 一直往前！贪心法

1. 贪心算法：遵循某种规律，不断贪心选取当前最优策略。
2. 贪心证明：
    - 与其它选择方案相比，该算法并不会得到更差的解（归纳法）
    - 不存在其他的解决方案（反证法）

#### 2.2.1 硬币问题

[月饼](https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805399578853376)

[零钱兑换](https://leetcode.cn/problems/coin-change/description/)



#### 2.2.2 区间问题



#### 2.2.3 字典序最小问题

## 



### 2.3 记录结果再利用的“动态规划”

#### 2.3.1 记忆化搜索与动态规划



[**背包问题**](https://oi-wiki.org/dp/knapsack/)  [**背包九讲**](https://www.kancloud.cn/kancloud/pack/70125)

**DP分析**

- 状态表示
  - 集合：所有只从前`i`个物品中，选出总重量不超过j的选法的集合
  - 属性：max, min, count 方案数
- 状态计算：
  - 选第`i`件物品
  - 不选第`i`件物品

一般将`i`从1开始计算，`dp[0][j]`表示一件物品也不选



- **0-1背包**，`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`，滚动数组优化`dp[j] = max(dp[j], dp[j-w[i]] + v[i])`

- **完全背包，**`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i], dp[i-1][j-2*w[i]]+2*v[i], ....dp[i-1][j-k*w[i]] + k*v[i])`，`dp[i][j-w[i]] = max(dp[i-1][j-w[i]], dp[i-1][j-2w[i]]+v[i], dp[i-1][j-3*w[i]]+2*v[i]. dp[i-1][j-k*w[i]] + (k-1)*v[i])`

  可以得到`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])`，

  滚动数组优化` dp[j] = max(dp[j], dp[j-w[i]] + v[i])`;**（从小到大）**

- **多重背包**，`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i], dp[i-1][j-2*w[i]]+2*v[i], ....dp[i-1][j-k*w[i]] + k*v[i])`

  和完全背包相比，多重背包中的物品数量是有限个，**二进制优化，滑动窗口**

- **分组背包**，

- 



##### [01背包](https://www.acwing.com/problem/content/2/)

>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。
>
>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。
>
>**限制条件**
>
>0 < N, V ≤ 10000 <N, V ≤ 1000
>0 <`vi, wi `≤ 1000



（1）最朴素的解法，枚举

对于每个物品要么放在背包中，要么不放在背包中，时间复杂度$O(2^N)$

```c++
int slove(int i, int j){    //从第i个物品开始挑选总重<j的部分
    if (i == n)             //没有剩余的物品了
        res = 0;
    else if (j < weight[i]){//第i件物品的重量超过了j，装不下
        res = slove(i+1, j);
    }else{                  //装得下
        res = max(slove(i+1, j-weight[i])+value[i], slove(i+1, j));
    }
    return res;
}
```

另外一种写法

```c++
void slove(int i, int j, int k){
    res = max(res, k);
    if (i == n)             //没有剩余的物品了
        return ;
    if (j+weight[i] > v){	//第i件物品的重量超过了j，装不下
        slove(i+1, j, k);
    }else{                  //装得下
        slove(i+1, j, k);
        slove(i+1, j+weight[i], k+value[i]);
    }
    return ;
}
```



（2）枚举+记忆化搜索

对于slove(i, j)会有很多重复的计算，但这些计算实际上并不需要

通过记忆化搜索，能够让每个slove(i, j)只计算一次，一共有`N*V`种组合，所以时间复杂度为$O(NV)$

```c++
int slove(int i, int j){
    if (dp[i][j] >= 0) return dp[i][j];
    int res;
    if (i == n)             //没有剩余的物品了
        res = 0;
    else if (j < weight[i]){//第i件物品的重量超过了j，装不下
        res = slove(i+1, j);
    }else{                  //装得下
        res = max(slove(i+1, j-weight[i])+value[i], slove(i+1, j));
    }
    dp[i][j] = res;
    return res;
}
```



（3）动态规划

根据前面`dp[i][j]`的定义，**从前i件物品中选取重量不超过j可以获得的最大价值**

对于每种物品而言只有选和不选，这两种情况

```c++
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])	//j <= w[i]
```

所以不需要写递归函数，可以利用上面的递归式进行计算，得到`dp[n][v]`的结果

```c++
for (int i = 1; i <= n; i++){
    for (int j = 0; j <= v; j++){
        dp[i][j] = dp[i-1][j];
        if (j >= weight[i])
        	dp[i][j] = max(dp[i][j], dp[i-1][j-weight[i]] + value[i]);
    }
}
return dp[n][v];
```

**需要注意的是，`dp[i][j]`的计算，i从1开始，如果从0开始就不能确定下标为0的物品是否被选中**



（4）一维动态规划

在上面的式子中我们可以发现，`dp[i][j]`之和上一行的`dp[i-1][j] dp[i-1][j-w[i]]`有关，那么使用滚动数组来优化空间复杂度，将空间复杂度从O(n * m)降低为O(m)

```c++
for (int i = 1; i <= n; i++){
        for (int j = v; j >= weight[i]; j--){
            dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);
        }
    }
```



从上面的过程我们可以得到求解DP问题的一般做法：

> （1）**问题定义**，根据题目描述抽象出`dp[i][j] dp[i][j][k]...`的定义，需要注意的是：是否包含i例如前i个，那么我们在计算式应该从`dp[i][j]  i=1 -> i =n`，如果是闭区间那么计算方式应该从`dp[i][j]  i=1 -> i =n-1`
>
> （2）**确定边界条件**，对于上面的问题如果从前0个物品选择（没有物品可供选择），或者是背包容量为0时，那么`dp[i][j] = 0`（由于我们将dp数组定义为全局变量，默认值为0所以在上面的代码中可以省略）
>
> （3）**状态转移方程**，这是dp问题解决的核心，如何将一个问题转换成和原问题类似规模更小的子问题，同时做到不重不漏（有时候可以重复，但一定不能漏掉解）
>
> （4）**确定计算方式**，一般来说可以在表格上进行演算，确定`dp[i][j]`的更新方式，从左到右从上到下等等

**示例**

**核心：如何将问题转换成背包问题，题目中的数据对应背包问题中的什么变量**

[零钱兑换](https://leetcode.cn/problems/coin-change/)

[一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)

[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)





****





##### [最长公共子序列LCS](https://leetcode.cn/problems/longest-common-subsequence/)

>给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。
>
>一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
>- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。
>
>两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。
>
>**限制条件**
>
>`1 <= text1.length, text2.length <= 1000`
>
>`text1` 和 `text2` 仅由小写英文字符组成。

（1）`dp[i][j]`text1前i个字符和text2前j个字符的最长公共子序列长度，即text1[0...i-1]和text2[0...j-1]之间的最长公共子序列长度，那么`dp[n][m]`就是所求的结果

（2）边界条件，`dp[0][0...m]`和`dp[0...n][0]`均为0，即任何一个空串和其他串的最长公共子序列长度均为0

（3）状态转移方程，如果`tex1[i-1]`和`text2[j-1]`两个字符相等，那么`dp[i][j] = dp[i-1][j-1] + 1`，否则说明两个字符不相等，那么两个最长公共子串只可能出现在`text1[0...i-1] text2[0...j]`或`text1[0...i] text2[0...j-1]`之间，可以得到状态转移方程`dp[i][j] = dp[i-1][j-1] text1[i] == text2[j]`，否则`dp[i][j] = max(dp[i][j-1], dp[i-1][j]) text1[i] != text2[j]`

（4）确定计算方式，`dp[i][j]`上一行的`dp[i-1][j]`以及左边的`dp[i][j-1]`有关

这里`dp[i][j]`需要同时用到上一行和当前行左边，只使用一个滚动数组优化不可行

```c++
$class Solution {
public:
    int longestCommonSubsequence(string s, string t) {
        int n = s.size(), m = t.size();
        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                if (s[i-1] == t[j-1])   dp[i][j] = dp[i-1][j-1]+1;
                else    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
        }
        return dp[n][m];
    }
};
```

**使用两个数组滚动进行优化，空间复杂度$O(m)$**

```c++
class Solution {
public:
    int longestCommonSubsequence(string s, string t) {
        int n = s.size(), m = t.size();
        vector<vector<int>> dp(2, vector<int> (m+1, 0));
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                if (s[i-1] == t[j-1])   dp[i & 1][j] = dp[(i-1) & 1][j-1]+1;
                else    dp[i & 1][j] = max(dp[i & 1][j-1], dp[(i-1) & 1][j]);
            }
        }
        return dp[n & 1][m];
    }
};
```

****





#### 2.3.2 进一步探讨递推关系





##### [完全背包](https://www.acwing.com/problem/content/3/)

>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。
>
>第 ii 种物品的体积是 vi，价值是 wi。
>
>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
>输出最大价值。
>
>**限制条件**
>
>0 < N, V ≤ 10000 < N, V ≤ 1000
>0 < vi, wi ≤ 1000

和01背包的区别在于，完全背包中对于物品的数量没有限制，一件物品选取之后仍可以重复选取

（1）动态规划

状态转移方程：`dp[i][j] = max(dp[i-1][j-k*w[i]] + k*v[i]) k*w[i] <= j`

```c++
for (int i = 1; i <= n; i++){
    for (int j = 1; j <= m; j++){
        for (int k = 0; k*w[i] <= j; k++){
        	dp[i][j] = max(dp[i][j], dp[i-1][j-k*w[i]] + k*v[i]);
        }
    }
}
```

对于上面的代码，形成了三重循环，最坏的情况k从0到w，时间复杂度$O(NW^2)$



（2）改进的动态规划

对于状态转移方程：`dp[i][j] = max(dp[i-1][j-k*w[i]] + k*v[i]) k*w[i] <= j`

考虑`dp[i][j-w[i]] = max(dp[i-1][j-w[i]-(k-1)*w[i]] + (k-1)*v[i]) `

​									=  `max(dp[i-1][j-k*w[i]] + (k-1)*v[i])`

所以`dp[i][j] = max(dp[i-1][j-k*w[i]] + k*v[i]) `

​						`= max(dp[i-1][j-k*w[i]] + (k-1)*v[i]) + v[i] `

​					  `= dp[i][j-w[i]] + v[i]`

实际上并不需要枚举k，我们可以从`dp[i][j-w[i]]`推导出`dp[i][j]`的值

经过上面的优化之后，时间复杂度降为$O(NW)$

```c++
for (int i = 1; i <= n; i++){
    for (int j = 1; j <= m; j++){
        dp[i][j] = dp[i-1][j];
        if (j >= w[i])
        	dp[i][j] = max(dp[i][j], dp[i][j-w[i]] + v[i]);
    }
}
```



（3）滚动数组进行优化

```
for (int i = 1; i <= n; i++){
    for (int j = w[i]; j <= m; j++){
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

也可以利用两个数组滚动，计算dp[i]时只需要利用dp[i]和d[i+1]

```c++
for (int i = 1; i <= n; i++){
    for (int j = 1; j <= m; j++){
        dp[(i+1) & 1][j] = dp[i & 1][j];
        if (j >= w[i])
        	dp[(i+1) & 1][j] = max(dp[(i+1) & 1][j], dp[(i+1) & 1][j-w[i]] + v[i]);
    }
}
return dp[(n+1) & 1][m];
```

**示例**

[零钱兑换](https://leetcode.cn/problems/coin-change/)

（1）二维dp

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        /*
        *   完全背包问题dp[i][j]表示前i枚硬币凑成j需要的最少硬币数
        *   dp[i][j] = min(dp[i-1][j], dp[i-1][j-coins[i]]+1, ..., dp[i-1][j*k*coins[i]]+k)
        *   dp[i][j] = min(dp[i-1][j], dp[i][j-conis[i]]+1)
        *   dp[i&1][j] = min(dp[(i-1) & 1][j], dp[i&1][j-cois[i]]+1)
        */
        int n = coins.size(), INF = 0x3f3f3f3f;
        vector<vector<int>> dp(2, vector<int> (amount+1, INF));
        dp[0][0] = 0;
        // for (int i = 1; i <= n; i++){
        //     for (int j = 1; j <= amount; j++){
        //         dp[i][j] = dp[i-1][j];
        //         if (j >= coins[i-1]) dp[i][j] = min(dp[i][j], dp[i][j-coins[i-1]]+1);
        //     }
        // }
        for (int i = 1; i <= n; i++){
            for (int j = 0; j <= amount; j++){
                dp[i & 1][j] = dp[(i-1) & 1][j];
                if (j >= coins[i-1]) dp[i & 1][j] = min(dp[i & 1][j], dp[i & 1][j-coins[i-1]]+1);
            }
        }
        return dp[n&1][amount] == INF ? -1 : dp[n&1][amount];
    }
};
```

（2）一维dp

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size(), INF = 0x3f3f3f3f;
        //dp[i] = min(dp[i-coins[1]], dp[i-coins[2]], ..., dp[i-coins[n-1]])+1
        vector<int> dp(amount+1, INF);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++){
            for (int j = 0; j < n; j++){
                if (i >= coins[j])  dp[i] = min(dp[i], dp[i-coins[j]] + 1);
            }
        }
        return dp[amount] != INF ? dp[amount] : -1;
    }
};
```

****





01背包问题2

> 有 N 件物品和一个容量是 W 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。
>
> **限制条件**
>
> 0 ≤  N ≤ 100， 1 ≤ wi ≤ $10^7$，   
> 0 ≤  vi ≤ 100， 1 ≤ W ≤ $10^9$，

这里如果继续使用之前`dp[i][j]`的定义，那么$O(NW)$的时间复杂度必然会超出时间限制

可以看到上面式子中的vi值比较小而wi的值吧较大，将`dp[i][j]`定义为从前i件物品中选取价值为j的重量的最小值

那么`dp[i][j]`中≤W的最大j就是答案

这里求解的是最小值，所以在数组初始化时应该将初值赋成一个较大的数

`dp[i][j]`前i件物品中价值为j的物品的最小重量
`dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])`
`dp[0][0] = 0, dp[0][j] = INF`

```c++
int dp[N][N*W + 10];

fill(dp[0], dp[0]+N*N, INF);
for (int i = 1; i <= n; i++){
    for (int j = 1; j <= N*W; j++){
        dp[i][j] = dp[i-1][j];
        if (j >= weight[i])
            dp[i][j] = min(dp[i][j], dp[i][j-value[i]] + weight[i]);
    }
}

int res = 0;
for (int j = 1; j <= N*N; j++)
    if (dp[n][j] <= v)
    	res = max(res, j);
```

****





##### [多重背包问题](https://www.acwing.com/problem/content/4/)

> 有 N种物品和一个容量是 V的背包。
>
> 第 i种物品最多有 si件，每件体积是 vi，价值是 wi。
>
> 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
> 输出最大价值。
>
> **输入格式**
>
> 第一行两个整数，N，用空格隔开，分别表示物品种数和背包容积。
>
> 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。
>
> **输出格式**
>
> 输出一个整数，表示最大价值。
>
> **数据范围**
>
> 0<N,V≤1000
> 0<vi,wi,si≤1000
>
> **输入样例**
>
> ```
> 4 5
> 1 2 3
> 2 4 1
> 3 4 3
> 4 5 2
> ```
>
> **输出样例：**
>
> ```
> 10
> ```

状态转移方程：

`dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]]+w[i], dp[i-1][j-2v[i]]+2w[i], ...., dp[i-1][j-k*v[i]+k*w[i])`

`0 <= k <= si`

时间复杂度：$O(NVS)$





**[多重背包的二进制优化](https://www.acwing.com/problem/content/5/)**

> 有 N种物品和一个容量是 V的背包。
>
> 第 i 种物品最多有 si件，每件体积是 vi，价值是 wi。
>
> 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
> 输出最大价值。
>
> **输入格式**
>
> 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
>
> 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
>
> **输出格式**
>
> 输出一个整数，表示最大价值。
>
> **数据范围**
>
> $0<N≤10000$
> $0<V≤20000$
> $0<vi,wi,si≤20000$
>
> **提示：**
>
> 本题考查多重背包的二进制优化方法。
>
> **输入样例**
>
> ```
> 4 5
> 1 2 3
> 2 4 1
> 3 4 3
> 4 5 2
> ```
>
> **输出样例：**
>
> ```
> 10
> ```

多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有多$k_i$个，而非一个。

一个很朴素的想法就是：把「每种物品选$k_i$次」等价转换为「有$k_i$个相同的物品，每个物品选一次」。这样就转换成了一个 0-1 背包模型，套用上文所述的方法就可已解决。状态转移方程如下：
$$
f_{i,j}=max(f_{i-1,j-k\times w_i}+v_i\times k) k \in [0, ki]
$$
时间复杂度 $O(W\sum_{i=1}^nk_i)$



**二进制分组优化**

考虑优化。我们仍考虑把多重背包转化成 0-1 背包模型来求解。

**解释**

显然，复杂度中的 $O(nW)$部分无法再优化了，我们只能从$O(\sum k_i)$ 处入手。为了表述方便，我们用$A_{i,j}$ 代表第 ![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 种物品拆分出的第j个物品。

在朴素的做法中，$\forall j\le k_i, \quad A_{i,j}$均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 $A_{i,1}, A_{i,2}$」与「同时选 」$A_{i,2}, A_{i,3}$这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。

**过程**

我们可以通过「二进制分组」的方式使拆分方式更加优美。

具体地说就是令 ![A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 分别表示由 ![2^{j}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 个单个物品「捆绑」而成的大物品。特殊地，若 ![k_i+1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 不是 ![2](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的整数次幂，则需要在最后添加一个由 ![k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 个单个物品「捆绑」而成的大物品用于补足。

举几个例子：

- ![6=1+2+3](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)
- ![8=1+2+4+1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)
- ![18=1+2+4+8+3](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)
- ![31=1+2+4+8+16](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)

显然，通过上述拆分方式，可以表示任意 ![\le k_i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。

时间复杂度 

**利用二进制优化**

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n, m;
const int N = 12010;
int dp[N], v[N], w[N];
//使用二进制优化来解决多重背包问题
//任何一个整数都可以通过k = 2^0 + 2^1 +... + 2^i + ... + t来进行表示
//将k进行分解，i组的背包重量修改为物品i的2^i倍，价值也变为原来的2^i倍
//最后使用0-1背包的方式进行求解

int main(){
    int cnt = 0;
    cin>>n>>m;
    for (int i = 1; i <= n; i++){
        int a, b, s;    //分别表示第i个物品的体积、价值和数量
        cin >> a >> b >>s;
        int k = 1;
        while(k <= s){
            cnt++;
            v[cnt] = a*k;
            w[cnt] = b*k;
            s -= k;
            k *= 2;
        }
        if (s){
            cnt++;
            v[cnt] = a*s;
            w[cnt] = b*s;
        }
    }
    n = cnt;
    for (int i = 1; i <= n; i++){
        for (int j = m; j >= v[i]; j--){
             dp[j] = max(dp[j], dp[j-v[i]]+w[i]);
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```

****



##### [分组背包问题](https://www.acwing.com/problem/content/9/)

> 有 N组物品和一个容量是 V 的背包。
>
> 每组物品有若干个，同一组内的物品最多只能选一个。
> 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。
>
> 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
>
> 输出最大价值。
>
> **输入格式**
>
> 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。
>
> 接下来有 N组数据：
>
> - 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
> - 每组数据接下来有 Si行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；
>
> **输出格式**
>
> 输出一个整数，表示最大价值。
>
> **数据范围**
>
> 0<N,V≤1000
> 0<Si≤1000
> 0<vij,wij≤1000
>
> **输入样例**
>
> ```
> 3 5
> 2
> 1 2
> 2 4
> 1
> 3 4
> 1
> 4 5
> ```
>
> **输出样例：**
>
> ```
> 8
> ```

`dp[i][j]前i组中选取重量不超过j的物品得到的最大值
每组物品中最多只可以选一种
dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i][1]] + w[i][1], ...., dp[i-1][j-v[i][k]] + w[i][k])
利用滚动数组进行优化
dp[j] = max(dp[j], dp[j-v[i][1]] + w[i][1], ... , dp[j-v[i][k]] + w[i`][k]`

```c++
#include <iostream>
using namespace std;

const int MAX_N = 110;
int N, V, w[MAX_N][MAX_N], v[MAX_N][MAX_N], dp[MAX_N], s[MAX_N];

int main(){
    cin >> N >> V;
    for (int i = 1; i <= N; i++){
        cin >> s[i];
        for (int j = 1; j <= s[i]; j++) cin >> v[i][j] >> w[i][j];
    }
    for (int i = 1; i <= N; i++){
        for (int j = V; j >= 0; j--){
            for (int k = 0; k <= s[i]; k++){
                if (j >= v[i][k])
                    dp[j] = max(dp[j], dp[j-v[i][k]] + w[i][k]);
            }
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```



##### [多重部分和](http://poj.org/problem?id=1742)

> 有n种不同大小的数字ai，每种各mi个。判断是否可以从这些数字之中选出若干个使他们的和恰好为K。
> **限制条件**
> 1<=n<=100
> 1<=ai,mi<=100000
> 1<=K<100000

（1）让`dp[i][j]`表示为从前i个数字中选取若干数字，是否能使其和为j

状态转移方程：`dp[i][j] = dp[i-1][j] | dp[i-1][j-a[i]] .... | dp[i-1][j-k*a[i]] | k≤ mi`

```c++
bool dp[N+1][K+1];

dp[0][0] = true;
for (int i = 1; i <= n; i++){
	for (int j = 1; j <= K; j++){
		for (int k = 0; k <= mi && k*a[i] <= j; k++){
			dp[i][j] |= dp[i-1][j-k*a[i]];
			if (dp[i][j])	break;
		}
	}
}
```

使用滚动数组进行优化

```c++
bool dp[K+1];

dp[0] = true;
for (int i = 1; i <= n; i++){
	for (int j = 1; j <= K; j++){
		for (int k = mi; k >= 0; k--){
			if (j >== k*a[i])
				dp[j] |= dp[j-k*a[i]];
			if (dp[j])	break;
		}
	}
}
```

时间复杂度$O(NKM)$



（2）让`dp[i][j]`用前i个数相加得到j时，第i种数最多还能剩余多少个（不能相加得到j时为-1）

如果`dp[n][K] ≥ 0`，说明前n个数凑成K之后还剩余的ai的个数≥ 0

如果前面i-1个数相加可以得到j，那么`dp[i][j]`为mi

如果前面i种数相加凑出j-a[i]时第i种数还剩k (k > 0)，那么再利用ai凑j时还剩的个数为k-1

状态转移方程：`dp[i][j] = mi		dp[i-1][j] >= 0`，前i-1个数可以凑成j，那么第i种数还剩余mi个

​								  			`= -1	    j < ai || dp[i][j-ai] ≤ 0`，ai的值太大或者利用前i-1个数凑不出j-ai

​									  		`= dp[i][j-ai] - 1`		在前i个数可以凑成j-ai的情况下，在使用一个ai	

```
int dp[K+1];

for (int i = 1; i <= n; i++){
	for (int j = 1; j <= K; j++){
		if (dp[j] >= 0)	dp[j] = mi;
		elee if (j < ai || dp[i][j-ai] <= 0)	dp[j] = -1;
		else dp[j] = dp[j-ai] - 1;
	}
}
```

这个递推式的时间复杂度$O(nK)$

****





##### [最长上升子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>
> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 2500`
> - $-10^4 <= nums[i] <= 10^4$
>
>  
>
> **进阶：**
>
> - 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

**（1）动态规划**

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        /*
        *   dp[i]以nums[i]为结尾的最长上升子序列的长度
        *   dp[i] = (1, dp[j] + 1)  0 <= j < i, nums[j] < nums[i]
        *   时间复杂度O(n*n)
        */
        int n = nums.size();
        vector<int> dp(n, 1);
        for (int i = 1; i < n; i++){
            for (int j = 0; j < i; j++){
                if (nums[j] < nums[i])  dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```



**（2）动态规划+二分查找**

利用sub数组来存储最长上升子序列，sub[i]是在长度为sub.size()的最小元素

对于nums[i]而言，如果当前的子序列为空或者大于sub的最后一个元素，使得nums[i]加入之后sub变得更长

否则nums[i] <= sub.back()，那么利用更小的nums[i]去更新sub中>=nums[i]的第一个元素，这样使得在相同长度下的递增子序列sub中的只更小，可以容纳更多的元素

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> sub;
        for (int i = 0; i < n; i++){
            if (sub.empty() || nums[i] > sub.back())
                sub.push_back(nums[i]);
            else{
                int pos = lower_bound(sub.begin(), sub.end(), nums[i]) - sub.begin();
                // if (pos >= 0 && pos < sub.size())   
                sub[pos] = nums[i];
            }
        }
        return sub.size();
    }
};
```

时间复杂度$O(nlogn)$

****





#### 2.3.3 有关计数问题的dp

##### [整数划分](https://www.acwing.com/problem/content/902/)

>  一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk, k≥1。
>
> 我们将这样的一种表示称为正整数 n 的一种划分。
>
> 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。
>
> **输入格式**
>
> 共一行，包含一个整数 n。
>
> **输出格式**
>
> 共一行，包含一个整数，表示总划分数量。
>
> 由于答案可能很大，输出结果请对 109+7取模。
>
> **数据范围**
>
> 1≤n≤1000
>
> **输入样例:**	5
>
> **输出样例：**	7

实际上是一个完全背包的应用，定义`dp[i][j]`为前i个数中选出一些数和恰好为j的方案数

将j看做背包中的体积，方案数等价于背包中的价值

对于第i个数，可以重复使用选0次、1次、2次、...k次

`dp[i][j] = dp[i-1][j] + dp[i-1][j-i] + dp[i-1][j-2*i] + ... + dp[i-1][j-k*i]`

利用完全背包优化的思路来优化上述代码，降低时间复杂度

`dp[i][j-i] = 			dp[i-1][j-i] + dp[i-1][j-2*i] + ... + dp[i-1][j-k*i]`

可以得到`dp[i][j] = dp[i-1][j] + dp[i][j-i]`

```c++
dp[0][0] = 1;   //一个数也不选也是一种方案
for (int i = 1; i <= N; i++){
    for (int j = 0; j <= N; j++){
        dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod;
        if (j >= i)
        	dp[i][j] = (dp[i][j] + dp[i][j-i]) % mod;
    }
}
return dp[N][N];
```

****





#### 线性dp

##### [数字三角形](https://www.acwing.com/problem/content/900/)

> 给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。
>
> ```
>         7
>       3   8
>     8   1   0
>   2   7   4   4
> 4   5   2   6   5
> ```
>
> **输入格式**
>
> 第一行包含整数 n，表示数字三角形的层数。
>
> 接下来 n 行，每行包含若干整数，其中第 i行表示数字三角形第 i层包含的整数。
>
> **输出格式**
>
> 输出一个整数，表示最大的路径数字和。
>
> **数据范围**
>
> 1≤n≤500
> −10000≤三角形中的整数≤10000
>
> **输入样例：**
>
> ```
> 5
> 7
> 3 8
> 8 1 0 
> 2 7 4 4
> 4 5 2 6 5
> ```
>
> **输出样例：**
>
> ```
> 30
> ```

可以按照题意自上而下进行计算，然后在遍历最后一行去(1, 1)到(i, j)路径上的最大值

从三角形的最底层出发，向上走最终会走到(1, 1)，那么返回`dp[1]`就是最终答案

`dp[i][j]从(i,j)到(1,1)的最大路径和
dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + nums[i][j]
利用滚动数组优化
dp[j] = max(dp[j], dp[j+1]) + nums[i][j]`

```c++
#include <iostream>
using namespace std;

const int N = 510;
int n, nums[N][N], dp[N];

int main(){
    cin >> n;
    for (int i = 1; i <= n; i++){    
        for (int j = 1; j <= i; j++)
            cin >> nums[i][j];
    }
    for (int i = n; i >= 1; i--){
        for (int j = 1; j <= i; j++)
            dp[j] = max(dp[j], dp[j+1]) + nums[i][j];
    }
    cout << dp[1] << endl;
    return 0;
}
```

****

##### [最长上升子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

##### [最短编辑距离](https://leetcode.cn/problems/edit-distance/)

>给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。
>
>你可以对一个单词进行如下三种操作：
>
>- 插入一个字符
>- 删除一个字符
>- 替换一个字符
>
>**示例 1：**
>
>```
>输入：word1 = "horse", word2 = "ros"
>输出：3
>解释：
>horse -> rorse (将 'h' 替换为 'r')
>rorse -> rose (删除 'r')
>rose -> ros (删除 'e')
>```



```c++
class Solution {
public:
    int minDistance(string s, string p) {
        int n = s.size(), m = p.size();
        if (n*m == 0)   return n+m;
        vector<vector<int>> dp(n+1, vector<int> (m+1, 0x3f3f3f3f));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++)
            dp[i][0] = i;
        for (int j = 0; j < m; j++)
            dp[0][j] = j;
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                if (s[i-1] == p[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;
            }
        }
        return dp[n][m];
    }
};
```

****





### 2.4 加工并存储数据的数据结构

数据结构指的是存储数据的方式。用不同的方式存储数据，可以对数据做不同的高效操作，这一节会讨论“堆”、“二叉搜索树”、“并查集”这三种数据结构。

#### 2.4.1 树和二叉树

![image-20230204112004072](../../AppData/Roaming/Typora/typora-user-images/image-20230204112004072.png)

#### 2.4.2 优先队列和堆

##### 1 优先队列

**priority_queue又称为优先队列，其底层是用堆(heap)来实现的**
**在优先队列中，队首元素是当前队列中优先级最高的一个**

###### （1）priority_queue的定义

```c++
#include <queue> 
using namespace std;

priority_queue<typename> name;
```



###### （2）priority_queue容器内元素的访问

和队列不一样，**优先队列没有front()、back()函数，**
**只能通过top()函数来访问队首元素(堆顶元素)，也就是优先级最高的元素**

###### （3）priority_queue常用函数实例解析

​	**（1） push()**

push(x)将x入队，时间复杂度O(log N)，其中N为当前优先队列中元素的个数

​	**（2）top()**

top()可以获得队首(堆顶)元素，时间复杂度O(log N)

​	**（3）pop()**

pop()令队首元素出队，时间复杂度O(log N)

​	**（4）empty()**

empty()检测priority_queue是否为空，为空返回true，不空返回false，时间复杂度O(1) 

​	**（5）size()**

size()返回priority_queue内元素的个数，时间复杂度O(1) 



###### （4）priority_queue内元素优先级的设置(重点)

​	**（1）基本数据类型的优先级设置**

在这里指的基本数据类型是int, char, double可以直接使用的数据类型
**默认是数值越大优先级越高(大根堆)** 

```c++
priority_queue<int> q; 
priority_queue<int, vector<int>, less<int>> q;
/*
int表示priority_queue中存储元素的类型，vector<int>是承载数据结构堆(heap)底层容器 
less<int>表示数字越大优先级越高
greater<int>表示数据越小优先级越高
*/
```

​	**(2)结构体的优先级的设置** 

运算符的重定义

```c++
struct cmp{
	bool operator()(ListNode *a, ListNode *b){
		return a->val > b->val;
	}
};
//优先队列中cmp函数的效果和sort中cmp的效果刚好相反 
```

**notes:**
**如果结构体中的数据较为庞大(例如出现字符串或数组)，可以使用引用来提高效率（在Leetcode中常用）**
**此时在参数中加上"const"、"&"**

```c++
struct cmp{
    bool operator()(const ListNode *a, const ListNode *b){
        return a->val > b->val;
    }
}; 
```

示例：

[743网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct cmp{
        bool operator()(ListNode* a, ListNode *b){
            return a->val > b->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, cmp> pq;
        for (ListNode* list : lists){    //初始时将每个链表的头结点入队
            if (list)   pq.push(list);
        }

        ListNode *dummy = new ListNode();
        ListNode *r = dummy;
        while(pq.size()){
            ListNode *cur = pq.top(); pq.pop();
            r->next = cur, r = cur;
            if (cur->next)  pq.push(cur->next);
        }
        r->next = nullptr;
        return dummy->next;
    }
};
```

****



##### 2 堆

![image-20230204142648399](../../AppData/Roaming/Typora/typora-user-images/image-20230204142648399.png)

在构建堆时，元素不断向上调整使其称为一颗大根堆或者小根堆

当堆顶元素删除之后，通过将最后的元素放到堆顶，并将堆顶元素不断下降来维护堆的性质

```c++
//建立一个小根堆
int heap[MAX_N], sz = 0;

void push(int x){
	int i = sz++;	//自己节点的编号
    while (i > 0){
        int p = (i-1) / 2;	//父节点的编号
        if (heap[p] <= x)	break;
        heap[i] = heap[p];
        i = p;
    }
    heap[i] = x;
}

int pop(){
    int res = heap[0];	//最小值
    int x = heap[--sz];	//将最后一个元素放到堆顶的位置
    int i = 0;
    while (2*i+1 < sz){
        int left = 2*i+1, right = 2*i+2;
        if (b < sz && heap[b] < heap[a])	a = b;//a指向值更小的元素
        if (heap[a] >= x)	break;
        heap[i] = heap[a];
        i = a;
    }
    heap[i] = x;
    return ret;
}
```

****





#### 2.4.3 二叉搜索树

###### 1 二叉排序树的定义

二叉排序树也叫二叉查找树，二叉搜索树

**左子树结点值** **<** **根结点值** **<** **右子树结点值**



###### 2 二叉排序树的查找

```c++
TreeNode* find(TreeNode*p, int x){
    while (p && p->val != x){
        if (p->val > x)	p = p->left;
        else p = p->right;
    }
    return p;
}
```



###### 3 二叉排序树的插入

二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时，再进行插入
 插入过程如下：

**若原二叉树为空，则直接插入结点**

**否则，若关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树**

**插入的结点一定是新添加的叶节点**

```c++
void insert(TreeNode* &p, int x){
	if (p == NULL){
		p = new TreeNode(x);
		return ;
	}
	if (p->val == x)	return ;
	else if (p->val > x)	insert(p->left, x);
	else	insert(p->right, x);
}
```



###### 4 二叉排序树的删除

在二叉排序树中删除一个结点，不能直接把以该结点为根的子树都删除，只删除该结点保留其他结点，同时还要确保二叉树的性质不会丢失

（1）若被删除结点没有左子树，那么就把右子树提上去。

（2）若需要删除的节点的左子树没有右子树，那么就把左子树提上去。

（3）以上两种情况都不满足，就把左子树中最大的节点提到需要删除的节点上。

```c++
TreeNode* remove(TreeNode* p, int x){
    if (!p)	
        return nullptr;
    else if (p->val > x)	p->left = remove(p->left, x);
    else if (p->val < x)	p->right = remove(p->right, x);
    else if (!p->left){
        TreeNode* q = p->right;
        delete p;
        return q;
    }else if (!p->left>right){
        TreeNodde* q = p->left;
        q->right = p->right;
        delete p;
        return q;
    }else{
        TreeNode* q = p->left;
        while (q->right->right)	q = q->right;
        TreeNode* r = q->right;	//左子树最大的节点
        q->right = r->left;
        r->left = p->left;
        r->right = p->right;
        delete p;
        return q;
    }
    return p;
}
```





###### 5 编程语言的标准库

在C++中，STL里有set和map容器，set是像前面所说的一样使用二叉搜索树维护集合的容器，而map是维护键和值对应的容器。 

**（i）  set常用解法详解**

**set翻译为集合，是一个内部自动排序且不含重复元素的容器**

```c++
#include <set>
using namespace std;
```

​	**1）set的定义**

`set<typename> name;`

​	**2）set容器内元素的访问**

**set只能通过迭代器进行访问**

只有vector和string这两个STL容器支持*(it + i)的访问方式

```c++
set<typename> ::iterator it; //等价于-> auto it

for (auto it = st.begin(); it != st.end(); it++){
	cout << *it << endl;
}
```

​	**3）set常用函数实例解析**

​		**(1) insert()**

insert(x)可以将x插入到set容器内，并自动递增排序和去重，时间复杂度$O(logN)$

​		**(2) find()**

```c++
find(value)	//返回set中值为value的迭代器
auto it = st.find(value)
st.find(value) != st.end() //则说明st中存在value的元素,如不存在则返回st.end()
```

时间复杂度$O(logN)$

​		**(3) erase()**

​			**1) 删除单个元素**

​		erase(it)删除迭代器it处的元素，时间复杂度O(1) 

​		erase(value)，value为需要删除的元素值，时间复杂度为O(logn)

​			**2) 删除一个区间的所有元素**

​		erase(first, last)删除[first, last)之内的所有元素，时间复杂度O(last-first)

set内部使用**红黑树**来实现，erase的时间复杂度为O(logn)

​		**(4) size()**

size()用来获得set内元素的个数,时间复杂度O(1) 

​		**(5) clear()**

clear()用来清空set内的所有元素,时间复杂度O(1) 

​		**(6) lower_bound()、upper()_bound()**

lower_bound(x)，返回>=x的第一个元素的迭代器
upper_bound(x)，返回>x的第一个元素的迭代器 

​	**4） set的常见用途**

**set的主要作用是自动排序并去重**
**使用vector来实现去重和自动排序:**

```c++
sort(nums.begin(), nums.end()) 		
nums.earse(unique(nums.begin(), nums.end()), nums.end())
```

​	**（1）元素不唯一**

​		使用multiset

​	**（2）去重，但是不排序**

​		使用unordered_set	#inclue <unordered_set> 



**（ii） map的常用用法详解**

map，翻译为映射，也是常用的STL容器。
**map可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)**  

（有时候用unordered_map不可以实现，但却用map可以，例如将二维坐标映射map<pair<int, int>, int>mp可以，但unordered_map会报错）

```c++
#include <map>
using namespace std;
```

**（1）map的定义**

```c++
map<typename1, typename2> mp;
     键的类型   值的类型
map<string, int> mp;
map<set<int>, int> mp;
```



**（2）map容器内元素的访问**

​		**1）通过下标进行访问**

mp[key] = value	 **map中的键是唯一的**

​		**2）通过迭代器访问**

```c++
auto it = mp.begin()
	//访问键it->first
	//访问值it->second
```

**map会按照键的大小，从小到大自动排序**



**（3）map常用函数实例解析**

​		**1）find()**

find(key)返回键为key的映射的迭代器，时间复杂度O(logN)，其中N为map中元素的个数

​		**2）earse()**

​			**1、删除单个元素**

```c++
mp.erase(it)	//it为需要删除元素的迭代器
mp.erase(key)	//key为欲删除的键
```

​			**2、删除一个区间内的所有元素**

```c++
mp.erase(first, last)	//删除[fiest, last)区间内的所有元素
```

​		**3）size()**

**size()获取mp中映射的个数**

​		**4）clear()**

clear()用来清空map中的所有元素，时间复杂度O(N)，其中N为map中元素的个数



**（4）map的常见用途**

​	1)、建立char、string和int之间的映射，使用map可以减少代码量

​	2)、需要判断大整数或者其他类型的数据是否存在的题目，可以把map当bool数组使用

​	3)、字符串和字符串之间的映射

**map中的键和值是唯一的，而如果一个键需要对应多个值，就只能使用multimap**
**不对map中的键进行排序，可以使用unordered_map来加快程序的运行**** 

**（5）map和unordered_map的异同**

[C++中unordered_map的用法详解](https://blog.csdn.net/zou_albert/article/details/106983268?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165521772716782390547218%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165521772716782390547218&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106983268-null-null.142^v14^pc_search_result_control_group,157^v14^new_3&utm_term=unordered_map&spm=1018.2226.3001.4187)

- **运行效率方面**：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。

- **占用内存方面**：map内存占用略低，unordered_map内存占用略高，而且是线性成比例的。

    **map**

    **优点**：

    - **有序性**，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。**红黑树**，内部实现一个红黑书使得map的很多操作在logn的时间复杂度下就可以实现，因此效率非常的高。

    **缺点**：

    - 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
        **适用处**：对于那些有顺序要求的问题，用map会更高效一些。

    **unordered_map**

    **优点**：内部实现了哈希表，因此其查找速度是常量级别的。
    **缺点**：哈希表的建立比较耗费时间
    **适用处**：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map

    **note**

    - 对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的





#### 2.4.4 并查集

[Leetcode并查集](https://leetcode.cn/leetbook/read/disjoint-set/oviefi/)

[知乎并查集](https://zhuanlan.zhihu.com/p/93647900)

并查集（Union Find）也叫「不相交集合（Disjoint Set）」，专门用于 动态处理 不相交集合的「查询」与「合并」问题。

很多数据结构都因为具有 动态 处理问题的能力而变得高效，例如「堆」「二叉查找树」等。所谓「动态」的意思是：要处理的数据不是一开始就确定好的，理解「并查集」动态处理数据的最好的例子是「最小生成树」算法（本专题第 3 节介绍）。

可以使用并查集的问题一般都可以使用基于遍历的搜索算法（深度优先搜索、广度优先搜索）完成，但是使用并查集会使得解决问题的过程更加清晰、直观。

![image-20230206132633938](../../AppData/Roaming/Typora/typora-user-images/image-20230206132633938.png)

并查集动态处理的两个问题

##### 1 查询（Find）

查询图中的两个顶点是不是在同一个集合中。

注意：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。

##### 2 合并（Union）

将两个不相交集合进行合并



按「秩」合并的意思是：让树的「秩」较小的树的根结点，指向树的「秩」较大的树的根结点。

这里的「秩」有两种含义，分别用于不同的场景：

按 size 合并，用于需要维护每个连通分量结点个数的时候；
按 rank 合并，绝大多数时候。

**初始化（按秩合并）**

```c++
inline void init(int n)
{
    for (int i = 1; i <= n; ++i)
    {
        fa[i] = i;
        rank[i] = 1;
    }
}
```

**合并（按秩合并）**

```c++
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);    //先找到两个根节点
    if (rank[x] <= rank[y])
        fa[x] = y;
    else
        fa[y] = x;
    if (rank[x] == rank[y] && x != y)
        rank[y]++;                   //如果深度相同且根节点不同，则新的根节点的深度+1
}
```

**并查集的实现**

```c++
int father[MAX_N], rank[MAX_N];

void init(int n){
    for (int i = 0; i < n; i++){
        father[i] = i;
        rank[i] = 1;	//rank表示并查集的高度
    }
}

int findFather(int x){
    if (x == father[x])
        return x;
    else
        return  father[x] = findFather(father[x]);
}

int unionSet(int a, int b){
    int faA = findFather(a), faB = findFather(b);
    if (faA == faB)	return ;
    if (rank[faA] < rank[faB]){
        father[faA] = faB;
    }else{
        gather[faB] = faA;
        if (rank[faA] != rank[faB])
        	rank[faA]++;
    }
}
```

[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/solutions/)

```c++
class Solution {
    int father[26] = {0};
public:
    bool equationsPossible(vector<string>& equations) {
        for (int i = 0; i < 26; i++)    //father[i]表示i的父节点就是i
            father[i] = i;
        for (string equation : equations){
            int a = equation[0] - 'a', b = equation[3] - 'a';
            if (equation[1] == '=')
                unionSet(a, b);
        }
        for (string equation : equations){
            int a = equation[0] - 'a', b = equation[3] - 'a';
            if (equation[1] == '!'){
                int faA = findFather(a), faB = findFather(b);
                if (faA == faB) return false;
            }
        }
        return true;
    }

    int findFather(int x){	//路径压缩
        if (x == father[x])
            return x;
        father[x] = findFather(father[x]);
        return father[x];
    }

    void unionSet(int a, int b){
        int faA = findFather(a);
        int faB = findFather(b);
        if (faA != faB)
            father[faA] = faB;
    }
};
```

[省份数量](https://leetcode.cn/problems/number-of-provinces/description/)

[冗余连接](https://leetcode.cn/problems/redundant-connection/)

[连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

[情侣牵手](https://leetcode.cn/problems/couples-holding-hands/)

[食物链](https://www.acwing.com/problem/content/description/242/)

> 动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。
>
> A吃 B，B 吃 C，C吃 A。
>
> 现有 N 个动物，以 1∼N 编号。
>
> 每个动物都是 A,B,C中的一种，但是我们并不知道它到底是哪一种。
>
> 有人用两种说法对这 N 个动物所构成的食物链关系进行描述：
>
> 第一种说法是 `1 X Y`，表示 X 和 Y 是同类。
>
> 第二种说法是 `2 X Y`，表示 X 吃 Y。
>
> 此人对 N个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。
>
> 当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
>
> 1. 当前的话与前面的某些真的话冲突，就是假话；
> 2. 当前的话中 X 或 Y 比 N 大，就是假话；
> 3. 当前的话表示 X 吃 X，就是假话。
>
> 你的任务是根据给定的 N和 K句话，输出假话的总数。
>
> **输入格式**
>
> 第一行是两个整数 N 和 K，以一个空格分隔。
>
> 以下 K 行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中 D 表示说法的种类。
>
> 若 D=1，则表示 X和 Y是同类。
>
> 若 D=2，则表示 X 吃 Y。
>
> #### **输出格式**
>
> 只有一个整数，表示假话的数目。
>
> **数据范围**
>
> 1≤N≤50000
> 0≤K≤1000000
>
> **输入样例：**
>
> ```
> 100 7
> 1 101 1 
> 2 1 2
> 2 2 3 
> 2 3 3 
> 1 1 3 
> 2 3 1 
> 1 5 5
> ```
>
> **输出样例：**
>
> ```
> 3
> ```

**并查集** 但是三种动物之间具有捕食关系
i-A, i-B, i-C
i-x表示"i属于种类x"
并查集每个组表示组内所有元素代表情况都同时发生或不同时发生

d = 1, x和y属于同一类   合并x-A和y-A, x-B和y-B, x-C和y-C
d = 2, x吃y             根据题意A吃B, B吃C, C吃A
那么x-A和y-B, x-B和y-C, x-C和y-A是同一类
合并x-A和y-B, x-B和y-C, x-C和y-A

```c++
#include <iostream>
using namespace std;

const int N = 50010;
int n, k, father[3*N];

void init(int n){
    for (int i = 1; i <= n; i++)
        father[i] = i;
}

int findFather(int x){
    if (x == father[x])
        return x;
    return father[x] = findFather(father[x]);
}

void unite(int a, int b){
    father[findFather(a)] = findFather(b);
}

bool same(int a, int b){
    return findFather(a) == findFather(b);
}

int main(){
    cin >> n >> k;
    int res = 0;
    init(3*N);      //x, x+N, x+2*N分别表示x-A, x-B, x-C
    for (int i = 0; i < k; i++){
        int d, x, y;
        cin >> d >> x >> y;
        if (x < 0 || x > n || y < 0 || y > n)   {
            res++;
            continue;
        }
        if (d == 1){
            //x和y属于同一类
            if (same(x, y+N) || same(x, y+2*N)){
                res++;
                continue;
            }
            unite(x, y), unite(x+N, y+N), unite(x+2*N, y+2*N);
        }else{
            //x吃y
            if (same(x, y) || same(x, y+2*N)){
                res++;
                continue;
            }
            unite(x, y+N), unite(x+N, y+2*N), unite(x+2*N, y);
        }
    }
    cout << res << endl;
    return 0;
}
```

****





### 2.5 它们其实都是"图"

#### 2.5.1 图

![image-20230207191005572](../../AppData/Roaming/Typora/typora-user-images/image-20230207191005572.png)

![image-20230207191030991](../../AppData/Roaming/Typora/typora-user-images/image-20230207191030991.png)

![image-20230207191051487](../../AppData/Roaming/Typora/typora-user-images/image-20230207191051487.png)

![image-20230207191128232](../../AppData/Roaming/Typora/typora-user-images/image-20230207191128232.png)

<img src="../../AppData/Roaming/Typora/typora-user-images/image-20230207191159878.png" alt="image-20230207191159878" style="zoom:80%;" />



#### 2.5.2 图的表示

###### 1 邻接矩阵	`G[MAX_N][MAX_N]`

###### 2 邻接表		`vector<int> G[MAX_N]`



#### 2.5.3 图的搜素

[染色法判定二分图](https://www.acwing.com/problem/content/862/)

> 给定一个 n 个点 m条边的无向图，图中可能存在重边和自环。
>
> 请你判断这个图是否是二分图。
>
> **输入格式**
>
> 第一行包含两个整数 n 和 m。
>
> 接下来 m行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。
>
> **输出格式**
>
> 如果给定图是二分图，则输出 `Yes`，否则输出 `No`。
>
> **数据范围**
>
> $1≤n,m≤10^5$
>
> **输入样例：**
>
> ```
> 4 4
> 1 3
> 1 4
> 2 3
> 2 4
> ```
>
> **输出样例：**
>
> ```
> Yes
> ```

**深度优先遍历**，对于v而言先将v染色遍历v的邻接点u，如果u被染色并且颜色相同返回false，未被染色那么试图将u染色

```c++
#include <iostream>
#include <vector>
using namespace std;

const int N = 100010;
int n, m, colored[N] = {0};
vector<int> G[N];

bool dfs(int v, int c){
    colored[v] = c;//将顶点v染成c
    for (int i = 0; i < G[v].size(); i++){
        if (colored[G[v][i]] == c)  //相邻的节点已经是相同的颜色
            return false;
        if (colored[G[v][i]] == 0 && !dfs(G[v][i], -c))   //不能将相邻节点染成其他颜色
            return false;
    }
    return true;
}

int main(){
    cin >> n >> m;
    while (m--){
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (int i = 1; i <= n; i++){
        if (colored[i] == 0 && !dfs(i, 1)){
            cout << "No" << endl;
            return 0;
        }
    }
    cout << "Yes" << endl;
    return 0;
}
```



#### 2.5.4 最短路问题

带权有向图G的最短路径问题，一般可分为两类：

（1）单源最短路径 图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra算法求解

（2）每一对顶点间的最短路径 可通过Floyd算法来求解

###### 1 单源最短路径 （Bellman-Ford算法）

Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。
(通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新)

记`d[i] = min{(d[j] + w[i][j])  edge = (i,j)∈E}`

表示起点s到终点为i的最短路径长度

```c++
const int N = 10010, M = 1010,INF = 0x3f3f3f3f;
int d[N], n, m;
struct edge {int from, to, cost; };
edge es[M];
memset(d, 0x3f, sizeof d);

void bellman_ford(int s){
	d[s] = 0;
	while (true){
        bool update = false;	//判断本次循环是否更新了d[]数组
        for (int i = 0; i < m; i++){
            int u = es[i].from, v = es[i].to, c = es[i].cost;
            if (d[u] != INF && d[u] + c < d[v]){//将es[i]作为边，更新d[v]能获得更短的距离
                d[v] = d[u] + c;
                update = true;
            }
        }
        if (!update)	break;
	}
}
```

对于最短路径而言，最多两个顶点u和v之间经过N-1个顶点（[k....v]），也就是说最多通过V-1条边，while循环最多执行V-1次

时间复杂度$O(NM)$。

如果在第N次也更新了d[]数组，那么最短路径在存在负环。

```c++
bool find_negative_loop(){
	memset(d, 0, sizeof d);
	
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++){
			int u = es[j].from, v = es[j].to, c = es[j].cost;
             if (d[u] != INF && d[u] + c < d[v]){//将es[i]作为边，更新d[v]能获得更短的距离
   	         	d[v] = d[u] + c;
                if (i == n-1)	//第n次也更新了d[]数组，那么图中存在负环
                    return true;
             }
		}
	}
	return false;
}
```

****

###### 2 单源最短路径 （Dijkstra算法）

1、Dijkstra算法求单源最短路径

两点之间的最短路径也包含了路径上其他顶点间的最短路径

**每次用已经求得的最短路径加入到其它路径中，看是否形成了更短的路径（贪心）**

在构造的过程中还设置了2个辅助数组：

（1）**dist[]**:记录源点v0到其他各顶点之间的最短路径长度，

他的初始状态为：若v0到vi有弧，则dist[i]为弧上的权值，否则dist[i]=∞

（2）path[]:path[i]表示从源点到顶点i之间的最短路径的前驱结点，

在算法结束时，可以根据其path[]数值追溯得到源点v0到顶点vi的最短路径



假设从v0出发，集合S最初只包含顶点v0 ，

邻接矩阵`arcs`表示带权有向图，`arcs[i][j]表示有向边<i,j>的权值  若不存在有向边<i,j>，则arcs[i][j]为∞`



**Dijkstra算法的步骤如下：**

（1）初始化，集合S初始化为`{v0}`，`dist`的初始值`dist[i]=arcs[v0][i]，i=1,2,…n`

（2）从顶点V-S（不在S中的顶点）选出`vj`，满足`dist[j]=min(dist[i] | vi∈V-S)`

vj就是当前求得一条从v0出发的最短路径的终点，并把vj加入集合S中

**(选取`dist[]`值最小且未在S中的顶点，并把该顶点加入集合S)**

（3）**修改从vj出发到集合V-S（不在S中的顶点）上任一顶点vk可达的最短路径长度：**

若`dist[j]+arcs[j][k] < dist[k]`，则更新`dist[k]= dist[j]+arcs[j`][k]

**（从`vj`出发到顶点`vk`的距离更短，修改`dist[k]`）**

（4）重复（2）（3）共n-1次，直到所有顶点都包含在S中

[Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 510, INF = 0x3f3f3f3f;
int n, m, d[N], G[N][N];
bool visited[N] = {false};

void Dijsktra(int s){
    fill(d, d+N, INF);
    d[s] = 0;
    for (int i = 1; i <= n; i++){
        //找到d[]最小且未被访问的顶点
        int u = -1, dist = INF;
        for (int j = 1; j <= n; j++){
            if (!visited[j] && d[j] < dist){
                u = j;
                dist = d[j];
            }
        }
        if (u == -1)    break;
        visited[u] = true;  //将u加入集合s中
        for (int v = 1; v <= n; v++){
            if (!visited[v] && d[u] != INF && d[u] + G[u][v] < d[v]){
                d[v] = d[u] + G[u][v];
            }
        }
    }
}

int main(){
    cin >> n >> m;
    fill(G[0], G[0] + N*N, INF);
    for (int i = 0; i < m; i++){
        int u, v, c;
        cin >> u >> v >> c;
        G[u][v] = min(G[u][v], c);
    }
    Dijsktra(1);
    d[n] == INF ? cout << "-1" << endl : cout << d[n] << endl;
    return 0;
}
```

**利用优先队列来优化时间复杂度**

> $1≤n,m≤1.5×10^5$
> 图中涉及边长均不小于 0，且不超过 10000
> 数据保证：如果最短路存在，则最短路的长度不超过 $10^9$

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

typedef pair<int, int> PII;
const int N = 151000, INF = 0x3f3f3f3f;
int n, m, d[N];
vector<PII> G[N];
bool visited[N] = {false};
priority_queue<PII, vector<PII>, greater<PII>> pq;	//利用优先队列（小根堆来存储）

void Dijsktra(int s){
    fill(d, d+N, INF);
    d[s] = 0;
    pq.push(PII(0, s));
    while(pq.size()){
        //找到d[]最小且未被访问的顶点
        PII p = pq.top();
        pq.pop();
        int u = p.second;
        if (visited[u]) continue;   //不加上这个会在最后一个用例超时
        visited[u] = true;
        for (int i = 0; i < G[u].size(); i++){
            int v = G[u][i].first, cost = G[u][i].second;
            if (!visited[v] && d[u] != INF && d[u] + cost < d[v]){
                d[v] = d[u] + cost;
                pq.push(PII(d[v], v));
            }
        }
    }
}

int main(){
    cin >> n >> m;
    for (int i = 0; i < m; i++){
        int u, v, c;
        cin >> u >> v >> c;
        G[u].push_back(PII{v, c});
    }
    Dijsktra(1);
    d[n] == INF ? cout << "-1" << endl : cout << d[n] << endl;
    return 0;
}
```

****

###### 3 任意两点间的最短路问题（Floyd算法）

利用DP来解决任意两点之间的最短路径。

即`d[k+1][i][j]`，为只使用顶点0-k和`i，j`的情况下`i`到`j`的最短路径

`k=-1`时，只使用`i，j`两个顶点，所以`d[0][i][j] = cost[i][j]`



只使用0-k时，对于`i`到`j`的最短路径而言，要么经过顶点k要么不经过顶点k

`d[k][i][j] = d[k-1][i][j])`	不经过顶点k

`d[k][i][j] = d[k-1][i][k] + d[k-1][k][j]`	经过顶点k

所以`d[k][i][j] = min(d[k][i][j], d[k-1][i][k] + d[k-1][k][j])`

只使用一个数组优化`d[i][j] = min(d[i][j], d[i][k] + d[k][j])`

[Floyd求最短路](https://www.acwing.com/problem/content/856/)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 210, INF = 0x3f3f3f3f;
int n, m, k, d[N][N], G[N][N];

void floyd(){
    for (int k = 1; k <= n; k++){
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= n; j++){
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}

int main(){
    fill(d[0], d[0] + N * N, INF);
    fill(G[0], G[0] + N * N, INF);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++){
        G[i][i] = 0;
    }
    while (m--){
        int x, y, z;
        cin >> x >> y >> z;
        G[x][y] = min(G[x][y], z);
    }
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            d[i][j] = G[i][j];
        }
    }
    floyd();
    while (k--){
        int x, y;
        cin >> x >> y;
        d[x][y] >= INF/2 ? cout << "impossible" << endl : cout << d[x][y] << endl;
    }
    return 0;
}
```

****



#### 2.5.5 最小生成树

连通图的生成树，是图的极小连通子图它包含图中的所有顶点,并且只含尽可能少的边

对于生成树来说，若砍去它的一条边，就会使生成树变成非连通图

若给它增加一条边，就会形成图中的一条回路



图G是带权连通无向图，**边的权值之和最小的那棵生成树，称为图G的最小生成树**



最小生成树的性质：

**1)最小生成树不是唯一的，即最小生成树的树形不唯一**

R中可能有多个最小生成树。**当图G中的各边权值互不相等时，G的最小生成树是唯一的（充分不必要条件）**

无向连通图G的边比顶点数少1,即G本身就是一棵树时，G的最小生成树就是它本身 

**2)最小生成树的边的权值之和总是唯一的并且是最小的**

**3)最小生成树的边数为顶点数减1树都是如此** 





###### 1 Prim算法

Prim算法 Kruskal算法都是基于**贪心算法**策略，都是针对于无向图

**初始时，从图中任取一顶点加入树T**

此时树中只有1个顶点，**之后选择一个距离当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都+1，以此类推。**

直到图中所有的顶点加入T，得到的T就是最小生成树，此时T中必有n-1条边

[Prim算法求最小生成树](https://www.acwing.com/problem/content/description/860/)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 510, INF = 0x3f3f3f3f;
int n, m, minCost[N], G[N][N];      //从集合X出发到每个顶点的最小权值
bool visited[N] = {false}; //用来标记顶点i是否在集合X中

void prime(){
    int res = 0;
    minCost[1] = 0;       //将顶点1加入到X中
    for (int i = 0; i < n; i++){
        //找到距离集合X最近的顶点
        int v = 0;
        for (int u = 1; u <= n; u++){
            if (!visited[u] && minCost[u] < minCost[v])
                v = u;
        }
        if (minCost[v] == INF){
            cout << "impossible" << endl;
            return;
        }
        visited[v] = true;
        res += minCost[v];
        for (int u = 1; u <= n; u++){
            minCost[u] = min(minCost[u], G[v][u]);
        }
    }
    cout << res << endl;
    return ;
}

int main(){
    cin >> n >> m;
    fill(minCost, minCost+N, INF);
    fill(G[0], G[0] + N*N, INF);
    while (m--){
        int u, v, w;
        cin >> u >> v >> w;
        G[u][v] = min(G[u][v], w);
        G[v][u] = min(G[v][u], w);
    }
    prime();
    return 0;
}
```

****

###### 2 Kruskal算法

与Prim算法从顶点开始扩展最小生成树不同，Kruskal（克鲁斯卡尔）算法是**一种按权值递增次序选择合适的边来**构造最小生成树的方法



初始时为只有n个顶点而无边的非连通图T={V,{}}，每个顶点自己构成一个连通分量，

然后**按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边**，若该边依附的顶点落在T中不同的连通分量上（**加入该边之后不会产生回路），则将此边加入T**，否则舍弃此边选取下一条权值最小的边。

以此类推，直至T中所有的顶点都在一个连通分量上

时间复杂度`O(eloge)`， Kruskal算法适合边稀疏的图

**使用Prim算法和Kruskal算法构造图的最小生成树，所得到的最小生成树可能相同，也可能不同，但最小生成树边的权值之和一定相同**

[Kruskal算法求最小生成树](https://www.acwing.com/problem/content/861/)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;
int n, m, fa[N];
struct edge{
    int u, v, w;
    bool operator< (const edge &W)const
    {
        return w < W.w;
    }
}es[2*N];

void init(){
    for (int i = 0; i <= n; i++)
        fa[i] = i;
}

int findFather(int x){
    if (x == fa[x])
        return x;
    return fa[x] = findFather(fa[x]);
}

void unite(int a, int b){
    fa[findFather(a)] = findFather(b);
}

bool same(int a, int b){
    return findFather(a) == findFather(b);
}

void kruskal(){
    int res = 0, cnt = 0;
    sort(es, es+m);
    for (int i = 0; i < m; i++){
        int u = es[i].u, v = es[i].v, w = es[i].w;
        if (!same(u, v)){
            unite(u, v);
            res += w;
            cnt++;
        }
    }
    if (cnt == n-1) cout << res << endl;
    else    cout << "impossible" << endl;
    return ;
}

int main(){
    cin >> n >> m;
    init();
    for (int i = 0; i < m; i++){
        int u, v, w;
        cin >> u >> v >> w;
        es[i] = {u, v, w};
    }
    kruskal();
    return 0;
}
```

[次短路径](http://poj.org/problem?id=3255)

> 求1-N的次短路径
>
> Sample Input
>
> ```
> 4 4
> 1 2 100
> 2 4 200
> 2 3 250
> 3 4 100
> ```
>
> Sample Output
>
> ```
> 450
> ```

次短路径，对于顶点v的次短路径要么是经过v的最短路径加上`G[u][v]`，要么是到u的次短路径加上`G[u][v]`

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

typedef pair<int, int> PII;
const int N = 150010, INF = 0x3f3f3f3f;
int n, m, d[N], sd[N];
vector<PII> G[N];
bool visited[N] = {false};
priority_queue<PII, vector<PII>, greater<PII>> pq;

void Dijsktra(int s){
    fill(d, d+N, INF);
    fill(sd, sd+N, INF);
    d[s] = 0;
    pq.push(PII(0, s));
    while(pq.size()){
        //找到d[]最小且未被访问的顶点
        PII p = pq.top();
        pq.pop();
        int u = p.second;
        if (visited[u]) continue;   //不加上这个会在最后一个用例超时
        visited[u] = true;
        for (int i = 0; i < G[u].size(); i++){
            int v = G[u][i].first, cost = G[u][i].second;
            int dist = d[u] + cost;
            if (dist < d[v]){		//更新最短路径
                swap(dist, d[v]);
                pq.push(PII(d[v], v));
            }
            if (dist > d[v] && dist < sd[v]){//更新次短路径
                sd[v] = dist;
                pq.push(PII(sd[v], dist));
            }
        }
    }
    cout << sd[n] << endl;
}

int main(){
    cin >> n >> m;
    for (int i = 0; i < m; i++){
        int u, v, w;
        cin >> u >> v >> w;
        G[u].push_back(PII(v, w));
        G[v].push_back(PII(u, w));
    }
    Dijsktra(1);
    return 0;
}
```

****





### 2.6 数学问题的解题窍门

#### 2.6.1 辗转相除法

###### 1 求最大公约数

利用辗转相除法计算最大公约数

```c++
int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a%b);
}
```

时间复杂度$O(log max(a, b))$

###### 2 扩展欧几里得算法

> 给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足 ai×xi+bi×yi=gcd(ai,bi)。

`ax + by = exgcd(a, b, x, y)`

利用上面gcd的方式，递归的来计算`ax + by = exgcd(b, b%a, y, x)`

假设`d = gcd(a, b, x, y) `，`by + (a%b) x = gcd(b, a%b, y, x) `

`b%a = b - (a/b) * b`，所以`by + (b - (a/b) * b) x = gcd(b, b%a, y, x)`

整理可以得到`ax + b(y - a/b x) = d`

如果b == 0，那么原式 = `ax + 0y= gcd(a, 0) = a`

显然x = 1，y = 0是一组解

```c++
int exgcd(int a, int b, int &x, int &y){
	int d = a;
	if (b == 0){
		x = 1, y = 0;
	}else{
		d = exgcd(b, a%b, y, x);
		y -= a/b * x;
	}
	return d;
}
```

****

##### 2.6.2 有关素数的基础算法

###### 1 素数判定

如果p是n的一个约数，那么n/p也是n的约数，约数在sqrt(n)左右成对分布

```c++
bool isPrime(int n){
	for (int i = 2; i <= n/i; i++){
		if (n%i == 0)	return false;
	}
	return true;
}
```

时间复杂度`O(sqrt(n))`

**约数枚举**

```c++
vector<int> divisolr(int n){
	vector<int> res;
    for (int i = 2; i <= n/i; i++){
        if (n%i == 0){
			res.push_back(i);
        	 if(n/i != i)	res.push_back(n/i);
        }
    }
    return res;
}
```

**整数分解**

```c++
map<int, int> prime_fator(int n){
	map<int, int> res;
	for (int i = 2; i <= n/i; i++){
		while(n%i == 0){
			res[i]++;
			n /= i;
		}
	}
	if (n != 1)	res[n] = 1;
	return res;
}
```

****

###### 2 埃氏筛法

利用之前得到的素数`prime[i]`，来筛去`prime[i]`的倍速`（2prime[i], 3prime[i], 4prime[i] .... kprime[i]）`

```c++
#include <iostream>
using namespace std;

const int N = 1000010;
int not_prime[N] = {false}; //首先所有的数都是素数，然后进行筛选

int main(){
    int n;
    cin >> n;
    int res = 0;
    not_prime[0] = not_prime[1] = true;
    for (int i = 2; i <= n; i++){
        if (!not_prime[i]){
            res++;
            for (int j = 2*i; j <= n; j += i)
                not_prime[j] = true;
        }
    }
    cout << res << endl;
    return 0;
}
```

时间复杂度`O(nloglogn)`



###### 3 区间筛法

> 计算区间[a, b)之间内的质数个数
>
> $a < b <= 10^{12}$
>
> $b - a < 10^6$

如果直接利用埃氏筛法求出[1, b)之间的质数那么肯定会超时

对于<b的合数而言，其质因子最大不超过sqrt(b)

利用埃氏筛法得到[2, sqrt(b)]之间的质数，在筛去在[a, b)内对应质数的倍数

```c++
typedef long long LL;
int N = 1000010;
int not_prime[N] = {false};			//筛选[2, sqrt(b)]之间的素数
int not_prime_interval[N] = {false}; //用来标记[a, b)之间的数是否为质数

void setment_sieve (LL a, LL b){
	for (LL i = 2; i <= b/2; i++){
        if (!not_prime[i]){
			for (LL j = 2*i; j*j < b; j += i)/筛选[2, sqrt(b)]之间的素数
                not_prime[i] = true;
             for (LL j = max(2LL, (a+i-1)/i)*i; j < b; j += i)
                not_prime_interval[j-a] = true; 
        }
    }
}
```







## 第三章 出类拔萃-中级篇

### 3.1 不光是查找值！“二分搜索”

#### 3.1.1 从有序数组中查找某个值

[数的范围](https://www.acwing.com/problem/content/791/)

>给定一个按照升序排列的长度为 n 的整数数组，以及 q个查询。
>
>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。
>
>如果数组中不存在该元素，则返回 `-1 -1`。

**二分查找**

```c++
#include <iostream>
using namespace std;

const int N = 100010;
int n, q, nums[N];

int lower_bound(int x){
    int low = 0, high = n;//返回>=x的第一个数的下标，可能所有数都小于x返回n+1
    while (low < high){
        int mid = low + (high - low) / 2;
        if (nums[mid] >= x) high = mid;
        else    low = mid+1;
    }
    return low;
}

int main(){
    cin >> n >> q;
    for (int i = 0; i < n; i++)    cin >> nums[i];
    while (q--){
        int x;
        cin >> x;
        int low = lower_bound(x), high = lower_bound(x+1);
        if (low == n || (nums[low] != x))   low = -1;
        if (nums[high-1] != x)  high = -1;
        if (low == -1 || high == -1)    
            cout << "-1 -1" << endl;
        else
            cout << low << " " << high-1 << endl;
    }
    return 0;
}
```

在C++的STL容器中实现了`lower_bound(first_iterator, last_iterator, val)`返回`>=val`的第一个元素的地址

`upper_bound(first_iterator, last_iterator, val)`返回`>val`的第一个元素的地址

```c++
//解决“寻找有序序列第一个满足某条件的元素的位置的固定模板”
//二分区间为左闭右闭区间[left, right]，初值必须能覆盖掉解的所有可能取值

int binary_search(int left, int right){
	while (left < right){				//当left == right时，说明找到了唯一的位置
		int mid = low + (high - low) / 2;
		if (条件成立)					//这里是寻找第一个位置，如果要寻找最后一个位置可以让left = mid
			right = mid;
		else
			left = mid+1;
	}
	return left;
}
```

**开区间实现**

```c++
//解决“寻找有序序列第一个满足某条件的元素的位置的固定模板”
//二分区间为左开右闭区间(left, right]，初值必须能覆盖掉解的所有可能取值

int binary_search(int left, int right){
	while (left+1 < right){				//当left+1 == right时，说明找到了唯一的位置
		int mid = low + (high - low) / 2;
		if (条件成立)					//这里是寻找第一个位置，如果要寻找最后一个位置可以让left = mid
			right = mid;
		else
			left = mid;
	}
	return right;
}
```

**在初始时，left = -1， right = n**



[数的三次方根](https://www.acwing.com/problem/content/792/)

> 给定一个浮点数 n，求它的三次方根。

只要满足单调性就可以利用二分查找

```c++
#include <iostream>
using namespace std;

int main(){
    double n, error = 1e-8;
    cin >> n;
    double left = -100, right = 100;
    while (right - left > error){
        double mid = left + (right - left) / 2;
        if (mid*mid*mid >= n)
            right = mid;
        else
            left = mid;
    }
    printf("%.6f", right);
    return 0;
}
```



#### 3.1.2 判断一个解是否可行

[Cable master](http://poj.org/problem?id=1064)

>N条绳子，分成K段，每条绳子的长度是Li，每条绳子最长的长度是多少，保留两位小数

**单调性：绳子越长，可以分成的段数越少，反之可以分成的段数越多**

**二分绳子的长度**

```c++
#include <iostream>
#include <cmath>
using namespace std;

const int N = 10010;
int n, k;
double nums[N];

bool judge(double x){
    //将所有的绳子分成长度为x的k段是否可行
    int sum = 0;
    for (int i = 0; i < n; i++)
        sum += (int) (nums[i] / x);
    return sum >= k;
}

int main(){
    cin >> n >> k;
    for (int i = 0; i < n; i++)
        cin >> nums[i];
    double left = 0, right = 0x3f3f3f3f ,eps = 1e-10;
    while (right - left > eps){
        double mid = left + (right - left) / 2;
        if (judge(mid)) left = mid;
        else right = mid;
    }
    printf("%.2f", floor(right * 100) / 100);	//保留小数点后两位
    return 0;
}
```



#### 3.1.3 最大化最小值

[**Aggressive cows**]( https://www.acwing.com/problem/content/4179/)

>**题目大意**：n个房子，m头牛，房子有一个横坐标，问将m头牛塞进房子，每两头牛之间的最大间隔是多少。

单调性：假设最大间隔为d，d越大在n个牛舍里面可以放置的牛的数量越少，反之可以放置的牛的数量越多

对最大间隔d进行二分

**使用贪心算法来判断d是否是一个可行解**

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int MAX_N = 100010;
int N, M, nums[MAX_N];

bool check(int d){
    //任意两头牛之间的距离>=d
    int last = 0;   //贪心：第一头牛放在nums[0]的位置
    for (int i = 1; i < M; i++){
        int cur = last + 1;     //当前牛的位置放在last之后
        while (cur < N && nums[cur] < nums[last] + d)//当两头牛之间的距离<d，不断向后寻找新的位置
            cur++;
        if (cur == N)   //第i头牛没有位置可以放置
            return false;
        last = cur;     //更新上一次放置牛的位置
    }
    return true;
}

int main(){
    cin >> N >> M;
    for (int i = 0; i < N; i++)
        cin >> nums[i];
    sort(nums, nums + N);
    int left = 0, right = nums[N-1] - nums[0];
    while (right - left > 1){
        int mid = (left + right) / 2;
        if (check(mid))
            left = mid;
        else    
            right = mid-1;
    }
    /*	二分查找有不同的形式，注意如果没处理好可能会陷入死循环
    while (left < right){
        int mid = (left + right + 1) >> 1;
        if (check(mid))
            left = mid;
        else    
            right = mid-1;
    }
    */
    cout << left << endl;
    return 0;
}
```

[礼盒的最大甜蜜度](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/)

> 给你一个正整数数组 `price` ，其中 `price[i]` 表示第 `i` 类糖果的价格，另给你一个正整数 `k` 。
>
> 商店组合 `k` 类 **不同** 糖果打包成礼盒出售。礼盒的 **甜蜜度** 是礼盒中任意两种糖果 **价格** 绝对差的最小值。
>
> 返回礼盒的 **最大** 甜蜜度*。*
>
> **示例 1：**
>
> ```
> 输入：price = [13,5,1,8,21,2], k = 3
> 输出：8
> 解释：选出价格分别为 [13,5,21] 的三类糖果。
> 礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。
> 可以证明能够取得的最大甜蜜度就是 8 。
> ```
>
> **示例 2：**
>
> ```
> 输入：price = [1,3,1], k = 2
> 输出：2
> 解释：选出价格分别为 [1,3] 的两类糖果。 
> 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。
> 可以证明能够取得的最大甜蜜度就是 2 。
> ```
>
> **示例 3：**
>
> ```
> 输入：price = [7,7,7,7], k = 2
> 输出：0
> 解释：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。
> ```
>
> **提示：**
>
> - `1 <= price.length <= 105`
> - `1 <= price[i] <= 109`
> - `2 <= k <= price.length`

**理解题意**

糖果的甜蜜度和愤怒的牛之间的距离是一样的

```c++
class Solution {
public:
    bool check(const vector<int> &price, const int &k, int x){
        //本质上和愤怒的牛一样，任意两头牛之间的距离>=x  ->  任意两颗糖果的价格差>=x
        int last = price[0], cnt = 1;
        for (int i = 1; i < price.size(); i++){
            if (price[i]-last >= x){
                cnt++;
                last = price[i];
            }
        }
        return cnt >= k;
    }

    int maximumTastiness(vector<int>& price, int k) {
        sort(price.begin(), price.end());

        int left = 0, right = price.back();
        while (right - left > 1){
            int mid = left + (right - left) / 2;
            if (check(price, k, mid)){
                left = mid;
            }else{
                right = mid;
            }
        }
        return left;
    }
};
```



[跳石头](https://www.acwing.com/problem/content/description/521/)

> 一年一度的“跳石头”比赛又要开始了！ 
>
> 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。
>
> 组委会已经选择好了两块岩石作为比赛起点和终点。
>
> 在起点和终点之间，有 N块岩石（不含起点和终点的岩石）。
>
> 在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。
>
> 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。
>
> 由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。
>
> #### 输入格式
>
> 输入文件第一行包含三个整数 L，N，M 分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。 
>
> 接下来 N� 行，每行一个整数，第 i 行的整数 Di（0 < Di < L）表示第 i 块岩石与起点的距离。
>
> 这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。
>
> #### 输出格式
>
> 输出文件只包含一个整数，即最短跳跃距离的最大值。
>
> #### 数据范围
>
> $0≤M≤N≤500000$
> $1≤L≤10^9$

```

```



#### 3.1.4 最大化平均值

>n个物品的重量和价值分别是`wi, vi`，从中选出k个物品使单位重量的价值最大
>
>样例输入：
>
>```basic
>3 2
>2 2
>5 3
>2 1
>```
>
>样例输出：
>
>```
>0.75 （选取第1个和第3个物品）
>```

试图使用**贪心算法**，对物品的单位重量的价值进行排序，从高到低选取k个

那么选取的是第1个物品和第二个物品，单位重量的价值 = （2 + 3）/ (2 + 5) = 0.714

**单调性：**对于单位重量的价值x而言，x越大满足的物品个数越少，反之满足的物品数量越少

**利用二分查找**来求最大的平均值

假设`check(x)`判断满足k个物品中单位重量的价值是否>=x

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int MAX_N = 10010;
int n, k, w[MAX_N], v[MAX_N];
double y[MAX_N];

bool check(double x){
    for (int i = 0; i < n; i++){
        y[i] = v[i] - x * w[i];
    }
    sort(y, y+n);
    double sum = 0;
    for (int i = 0; i < k; i++){
        sum += y[n-i-1];
    }
    return sum >= 0;
}

int main(){
    cin >> n >> k;
    double left = 0, right = 0, eps = 1e-10;
    for (int i = 0; i < n; i++){
        cin >> w[i] >> v[i];
        if (1.0 * v[i] / w[i] > right)
            right = v[i]/w[i];
    }
    while (right - left > eps){
        double mid = (right + left) / 2;
        if (check(mid)){
            left = mid;
        }else    
            right = mid;
    }
    cout << right << endl;
    return 0;
}
```



#### 3.1.5 summary

二分查找并不只限于查找元素值，**对于具有单调性的问题**，可以尝试使用二分查找

**练习**

[最小化数组中的最大值 ](https://leetcode.cn/problems/minimize-maximum-of-array/) ❤

> 给你一个下标从 **0** 开始的数组 `nums` ，它含有 `n` 个非负整数。
>
> 每一步操作中，你需要：
>
> - 选择一个满足 `1 <= i < n` 的整数 `i` ，且 `nums[i] > 0` 。
> - 将 `nums[i]` 减 1 。
> - 将 `nums[i - 1]` 加 1 。
>
> 你可以对数组执行 **任意** 次上述操作，请你返回可以得到的 `nums` 数组中 **最大值** **最小** 为多少。
>
> **示例 1：**
>
> ```
> 输入：nums = [3,7,1,6]
> 输出：5
> 解释：
> 一串最优操作是：
> 1. 选择 i = 1 ，nums 变为 [4,6,1,6] 。
> 2. 选择 i = 3 ，nums 变为 [4,6,2,5] 。
> 3. 选择 i = 1 ，nums 变为 [5,5,2,5] 。
> nums 中最大值为 5 。无法得到比 5 更小的最大值。
> 所以我们返回 5 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [10,1]
> 输出：10
> 解释：
> 最优解是不改动 nums ，10 是最大值，所以返回 10 。
> ```
>
> **提示：**
>
> - `n == nums.length`
> - `2 <= n <= 105`
> - `0 <= nums[i] <= 109`



**最大化最小值**

POJ 3258、POJ 3273、POJ 3104、POJ3045

**最大化平均值**

POJ 2976、POJ 3111

**最小化第k大的值**

POJ 2010、POJ 3662

**其他**

POJ 1759、POJ 3484



**tips:**

如果遇到死循环，可以修改循环条件

`while (left < right)`		和		`while (right - left > 1)`	根据题意返回left或者right







### 3.2 常用技巧精选（一）

#### 3.2.1 尺取法（滑动窗口）

[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

（1）前缀和 + 二分		时间复杂度$O(nlogn)$

（2）滑动窗口				时间复杂度$O(n)$



#### 3.2.2 反转（开关问题）

[K 连续位的最小翻转次数](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/)

[**Face The Right Way**](http://poj.org/problem?id=3276)

> 有n头牛，每头牛要么面朝前方或者面朝后方。现在可以连续驱使连续的k头牛反转。求使得所有的牛面朝前方的最小操作数和对应的k是多少？
>
> 1 ≤ *n* ≤ 5,000

上面两个题比较接近

[翻转问题技巧详解](https://blog.csdn.net/ac_hell/article/details/51077320)

例.给定一个01串，现有翻转规则：翻转某一个位置时其后面2个位置也会跟着翻转，也就是每次翻转都会翻转3个连续的位置。要将01串全部翻转为0，求最小的翻转次数

形似这类题的问题叫做翻转问题，也可以叫开关问题，对于这类题通常都会用到下面我要说的方法来解



①.若某一个位置被翻转了n次，则其实际上被翻转了n%2次，因为翻转2k次相当与没翻转，翻转2k+1次相当于翻转了1次，因为要求最小翻转次数，所以对于某一个位置要么只（主动）翻转一次，要么不（主动）翻转。

②.分析易知翻转的顺序并不影响最终结果。（理解不了可自己举个例子在纸上模拟下）

③.现在我们着眼于第1个位置，可知若要将第1个位置进行翻转只有翻转它自己，因为没有其他位置的翻转会引起它的翻转。由①可知若第1个位置为1则必须且进行翻转（并将其后2个进行连带翻转）且以后不再进行翻转，因为再进行翻转就一共翻转了2次相当于没翻转。然后着眼于第2个位置，由于第1个位置不再进行翻转，所以要想翻转第2个位置只有翻转它自己，因为没有其他位置的翻转会引起它的翻转.....................以此类推直至最后剩下的个数＜3个，因为每次都翻转3个，而剩下的少于3个了就不再进行考虑了，此时只需判断剩下的是否全为0的即可，若不全为0，则不存在全部翻转为0的方案



下面奉上几个题，当然赤裸裸套用上面方法是行不通的，在此基础上还需用到其他技巧

POJ-3279（翻转问题+位操作）

> 给一个m*b的01[矩阵](https://so.csdn.net/so/search?q=矩阵&spm=1001.2101.3001.7020)，每次翻动某个矩阵的时候也会翻动有相邻边的值，即上下左右和其本身的值都会改变，求在翻动次数最少并且在字母序最小的情况下，翻动次数的矩阵，第i行第j列的数表示翻动该矩阵的次数，如果无解，输出**IMPOSSIBLE.**
>
> 1≤ m, n ≤

**如果能确定第一行的状态，那么再从上往下进行翻转就可以得到一个翻转的序列**

**二进制枚举**

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 16, INF = 0x3f3f3f3f;
int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};
int m, n, tile[N][N], opt[N][N], flip[N][N];

int get(int x, int y){
    int c = tile[x][y] + flip[x][y];
    for (int i = 0; i < 4; i++){
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 0 && nx < m && ny >= 0 && ny < n)
            c += flip[nx][ny];
    }
    return c&1;
}

int calc(){
    //求出第一行确定情况下的最小操作数
    for (int i = 1; i < m; i++){
        for (int j = 0; j < n; j++){
            if (get(i-1, j))
                flip[i][j]++;
        }
    }
    
    //判断最后一行是否为全0
    for (int j = 0; j < n; j++){
        if (get(m-1, j))
            return INF;
    }
    
    //计算总共的翻转次数
    int res = 0;
    for (int i = 0; i < m; i++){
        for (int j = 0; j < n; j++){
            res += flip[i][j];
        }
    }
    return res;
}

int main(){
    int res = INF;
    cin >> m >> n;
    for (int i = 0; i < m; i++){
        for (int j = 0; j < n; j++)
            cin >> tile[i][j];
    }
    //二进制枚举
    for (int i = 0; i < 1<<n; i++){
        //flip数组置为0
        memset(flip, 0, sizeof flip);
        for (int j = 0; j < n; j++){
            //字典序最小的解，flip[0][n-1....1 0]对应i的二进制
            flip[0][n-1-j] = i>>j & 1;
        }
        int num = calc();
        if (res > num){
            res = num;
            mempcpy(opt, flip, sizeof flip);
        }
    }
    if (res == INF)
        cout << "IMPOSSIBLE" << endl;
    else{
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                cout << opt[i][j];
                j == n-1 ? cout << endl : cout << " ";
            }
        }
    }
    return 0;
}
```

POJ-1753（和3279没啥区别！）

POJ-2965



##### **集合的整数表示**

当元素比较少时，使用二进制编码会比较方便。集合{0, 1, ....,n-1}的子集可以用如下方式编码成整数：

`f(s) = ∑2^i (i∈S) `

利用整数来表示对应的集合

- 空集∅										                            0
- 只含有第i个元素的集合{i}                                1<<i
- 含有全部n个元素的集合{0, 1,2...n-1}               (1<<n) - 1
- 判断第i个元素是否属于集合S                           if (s >> i & 1)
- 向集合中加入第i个元素S∪{i}                          S | 1 << i
- 向集合中去除第i个元素S`\`{i}                            S & ~(1<<i)
- 集合S和T的并集S∪T                                         S | T
-  集合S和T的交集S∩T                                         S & T

字典序000 000 < 000  001 < 000 010 < .... < 111 111       

​                                                                                                                        

**1、将{0, 1, ..., n-1}的所有子集枚举出来**

```c++
for (int i = 0; i < 1<<n; i++){
	//对子集的处理
}
```

上面的顺序，按照{0}, {1}, {0, 1}...{0, 1, ...n-1}的升序顺序枚举

 

**2、枚举某个集合sup的子集**

这里sup是一个二进制码，其本身也是某个集合的子集。例如0110 1101 {1,2,4,5,7}这样的集合，要将0110 0000 {1,2}这样的子集或者0010 1101 {2, 4,5,7}这样的子集枚举出来。上面枚举1-n的所有子集是通过不断累加的方式进行枚举，而当前是子集枚举子集，对于0110 1101 {1,2,4,5,7} + 1得到0110 1110 {1,2,4,5,6}显然sub+1不一定是sup的子集 ，而且(sub+1) & sup虽然是sup的子集，但仍可能是sup，没有改变。

所以需要反过来，**把sup开始每次减1直到0为止。由于sub-1不一定是sup的子集，需要和sup进行按位与&**，这样可以将sup的所有子集按照降序的方式列举出来，(sub-1) & sup会忽略掉sup中的0而从sub中减去1

```c++
int sub = sup;
do{
    //对于子集的处理
	sub = (sub - 1) & sup;
}while (sub != sup)		
//处理完0之后，由于-1在计算机中以补码的形式进行存储，会有sub == sup
```



**3、枚举{0,1,2...n-1}包含的所有大小为k的子集方法**

通过使用**位运算**可以按照字典序升序的方式来列举出所有满足条件的二进制码

```c++
int comb = (1 << k) - 1;
while (comb < 1<<n){
	int x = comb & (-comb), y = comb + x;
	comb = ((comb & ~y) / x >> 1) | y;
}
```

按照字典序，最小的子集是{0,0,1...1}（1<<k-1），所以它作为初始值。

求comb其后的二进制码，例如0101 110 {1,3,4,5}之后的是0110 011{1,2,5,6}，0111 110 {1,2,3,4,5}之后的是1001 111 {0,3,4,5,6}

**求comb二进制编码的方法：**

（1）求出最低位1开始的连续区间（0101 110 -> 0001 110）

（2）将这一区间全部变为0并将左侧的0变为1 （0101 110 -> 0110 000）

（3）将(1)中取出的区间右移，直到剩下的1的个数减少一个（0001 110 -> 0000 011）

（4）将（2）和（3）得到的结果按位或（0110 000 | 0000 011 -> 0110 011）



0101 110 {1,3,4,5}的下一个大小为4的子集0110 011 {1,2,5,6}

`x = comb & (-comb)`，得到最低位为1的二进制数

`y = comb + x`，将最低位为1开始的连续为1的区间全部置为0并将区间左侧的那个0置为1

`comb & ~y`，得到最低位为1开始的连续区间，在comb中加上x没有变化的位y，在`~`y中全部取反的值。而最低位1开始的连续区间在`~`y中仍是1，区间左侧的那个0也是0.通过计算com & ~y可以得到最低位为1开始的连续区间。

comb = 0101 110，则x = 0000 010，y = 0110 000，z = 0001 110

y是（2）要求的值，那么首先将z不断右移，直到最低位为1

`z / x >> 1`可以得到（3）要求的值



#### 3.2.3 弹性碰撞







### 3.3 活用各种数据结构

#### 3.3.1 线段树





#### 3.3.2 树状数组

##### 1 lowbit运算

[二进制中1的个数](https://www.acwing.com/problem/content/803/)

```c++
int lowbit(int x){
	return x & -x;
}
```

`lowbit()`运算：非负整数x在二进制表示下最低位1及其后面的0构成的数值。
`lowbit(12)=lowbit([1100]2)=[100]2=4 `
在计算机存储整数中一般是采用补码存储，并且把补码所表示的整数x变成其相反数-x，相当于把x的每一位取反并加上1.

`lowbit(12) = (1100) & (0011 + 0001) = (1100) & (0100) = 0100 = 4` 



##### 2 树状数组及其应用

> 输入一个长度为 n 的整数序列。
>
> 接下来再输入 m 个询问，每个询问输入一对 l,r
>
> 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。
>
> #### 输入格式
>
> 第一行包含两个整数 n 和 m。
>
> 第二行包含 n 个整数，表示整数数列。
>
> 接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。
>
> #### 输出格式
>
> 共 m 行，每行输出一个询问的结果。
>
> #### 数据范围
>
> 1≤l≤r≤n
> 1≤n,m≤100000
> −1000≤数列中元素的值≤1000

（1）暴力枚举

每次计算`nums[l...r]`之间的元素和，时间复杂度O(nm)，显然会超时



（2）利用前缀和计算

定义数组sum[i]为前i个数的和，`sum[i] = nums[1] + nums[2] + ... + nums[i]`

对于区间和`nums[l...r] = sum[r] - sum[l-1]`，可以在O(1)的时间内求出区间和，为了方便计算数组从下标为1开始的位置存储

```c++
#include <iostream>
using namespace std;

const int N = 100010;
int nums[N], sum[N];

int main(){
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++){
        cin >> nums[i];
        sum[i] = sum[i-1] + nums[i];
    }
    while (m--){
        int l, r;
        cin >> l >> r;
        cout << sum[r] - sum[l-1] << endl;
    }
    return 0;
}
```

查询的时间复杂度O(m)



> 假设在查询的过程中可能随时给第x个整数加上一个整数v

如果使用前缀和进行计算，那么每次将`nums[x] + v`之后会影响之后的sum[x] sum[x+1]... sum[n]，修改这些数的时间复杂度为O(n)

修改k次，算法的时间复杂度为O(nm)



**树状数组 （Binary Indexed Tree）**

树状数组本质上仍然是一个数组，并且与sum数组类似，是一个用来记录和的数组。**只不过它存放的是从i号开始往前长度为`lowbit(i)`个整数之和，树状数组的下标必须从1开始**

<img src="C:\Users\hp-pc\AppData\Roaming\Typora\typora-user-images\image-20230222143145737.png" alt="image-20230222143145737" style="zoom:80%;" />

```
 tree[1]=A[1]
 tree[2]=A[1]+A[2]
 tree[3]=A[3]
 tree[4]=A[1]+A[2]+A[3]+A[4]
 tree[5]=A[5]
 tree[6]=A[5]+A[6]
 tree[7]=A[7]
 tree[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]
 tree[9]=A[9]
 tree[10]=A[9]+A[10]
 tree[11]=A[11]
 tree[12]=A[9]+A[10]+A[11]+A[12]
 ...
```

`t[x] = A[x - lowbit(x) + 1] + A[x - lowbit(x) + 2] + ... + A[x]`	//从A[x]开始往前`lowbit(x)`个数之和

`sum[x] = A[1] + A[2] + ... + A[x] = A[1] + A[2] + ... A[x - lowbit(x)] + A[x - lowbit(x) + 1] + ... + A[x]`

​		   `= A[1] + A[2] + ... A[x - lowbit(x)] + t[x] = sum[x - lowbit(x)] + t[x]`

**（1）求数组中前x个数的和**

```c++
int getSum(int x){
    int sum = 0;
    for (int i = x; i > 0; i -= lowbit(i))
        sum += t[i];
    return sum;
}
```

`getSum()`的时间复杂度$O(logn)$（树的高度为$O(logn)$，`lowbit(i)`就是不断沿着子节点求和）

**求数组下标在区间[l...r]内的树之和，即A[x] + A[x+1] + ... + A[y]，可以转换为`getSum(r) - getSum(l-1)`**



**（2）实现将第x个数加上一个整数v**

```c++
void update(int x, int v){
	for (int i = x; i <= n; i += lowbit(i))	//i必须能取到n
        t[i] += v;
}
```

update(x, v)的时间复杂度度$O(logn)$



> 给定N个正整数的序列A（$N≤10^5, A[i] <= 10^5$），对序列中的每个数，求出序列中它左边比它小的数的个数
>
> ```
> 输入: [5,2,6,1]
> 输出：[0,0,2,0] 
> ```

使用hash数组的做法，对于`A[i]`先让`hash[A[i]]++`，`A[i]`出现的次数+1，从左往右遍历`<A[i]`的数等于	hash[1] + hash[2] + ... + `hash[A[i-1]]`，利用树状数组的`update(A[i], 1)`和`getSum(A[i]-1)`来解决

```c++
int lowbit(x) {
	return x & -x;
}

void update(int x, int v){
    for (int i = x; i <= b; i += lowbit(i))
        t[i] += v;
}

int getSum(int x){
    int sum = 0;
    for (int i = x; i > 0; i--){
        sum += t[i];
    }
    return sum;
}

int slove(){
    for (int i = 1; i <= n; i++){
        lower[i] = getSum(A[i-1]);	//lower[i]表示在nums[i]左侧<nums[i]的元素个数
        update(A[i], 1);		   //A[i]出现的次数+1
    }
}
```



> 统计在序列中右边比nums[i]大（或比nums[i]）小的数的个数

从右往左进行遍历，对于右边比`nums[i]`小的个数 = `get(A[i]-1)`，比`nums[i]`大的个数 = `get(N) - get(nums[i-1])`



> 如果A[i] ≤ N不成立或者A[i]为负数，树状数组开不了这么大，应该如何解决呢
>
> A = {520, 9999999999, 18, 666, 88888}

如果只考虑它们之间的大小关系A等价于{2,5,1,3,4}，所以应该将A[i]和1-N对应起来

实际上等同于给定N个学生的成绩，然后对他们的成绩进行排名，分数相同则排名一致

**设置一个临时的结构体数组，用来存放输入序列的元素值和原始序号，在输入数据之后按照元素值val进行排序，排序完在按照计算排名的方式根据原始pos存入到新的数组当中，这种做法可以将不在合适区间的整数或者非整数转换为不超过元素个数大小的整数，这种技巧称为离散化**



[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/)

> 给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
>
> **示例 1：**
>
> ```
> 输入：nums = [5,2,6,1]
> 输出：[2,1,1,0] 
> 解释：
> 5 的右侧有 2 个更小的元素 (2 和 1)
> 2 的右侧仅有 1 个更小的元素 (1)
> 6 的右侧有 1 个更小的元素 (1)
> 1 的右侧有 0 个更小的元素
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-1]
> 输出：[0]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [-1,-1]
> 输出：[0,0]
> ```
>
> **提示：**
>
> - $1 <= nums.length <= 10^5$
> - $-10^4 <= nums[i] <= 10^4$

对于nums而言当中有负数，并不能直接使用树状数组，需要先进行离散化将nums中的元素按照大小关系映射到1-N中

```c++
class Solution {
private:
    static const int MAXN = 100010;
    struct Node{
        int val, pos;
        bool operator<(const Node node){	//运算符重载，重载小于号按照val的值进行比较
            return val < node.val;
        }
    }temp[MAXN];						  //用来离散化的临时结构体数组
    int n, a[MAXN], t[MAXN];			   //a[]是离散化之后的数组，t[]是树状数组

public:
    vector<int> countSmaller(vector<int>& nums) {
        n = nums.size();
        for (int i = 0; i < n; i++){
            temp[i] = {nums[i], i};		   //temp[i] = {nums[i], i}等价于temp[i].val = nums[i], temp[i].pos = i
        }
        sort(temp, temp+n);				  //按照val的从小到大进行排序
        for (int i = 0; i < n; i++){	   //离散化，本质上和按照学生的成绩进行排名一样
            if (i == 0 || temp[i].val != temp[i-1].val)
                a[temp[i].pos] = i+1;	   //离散化之后的元素存放到数组a[]中
            else
                a[temp[i].pos] = a[temp[i-1].pos];
        }
        vector<int> res(n, 0);
        for (int i = n-1; i >= 0; i--){
            res[i] = getSum(a[i]-1);	    //使用的是离散化之后得到的数组a[]
            update(a[i], 1);
        }
        return res;
    }
	
    //树状数组的lowbit()、update(x, v)、getSum(x)函数
    int lowbit(int x){
        return x & -x;
    }

    void update(int x, int v){
        for (int i = x; i <= n; i += lowbit(i))
            t[i] += v;
    }

    int getSum(int x){
        int sum = 0;
        for (int i = x; i > 0; i -= lowbit(i))
            sum += t[i];
        return sum;
    }
};
```



[数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
>
> **示例 1:**
>
> ```
> 输入: [7,5,6,4]
> 输出: 5
> ```
>
> **限制：**
>
> ```
> 0 <= 数组长度 <= 50000
> ```

和上面的思路一样，首先需要将nums数组进行离散化，对于离散化之后的数组当做新的数组来求逆序对。

对nums[i]而言，能和它构成逆序对的元素位于nums[i]左侧并且>nums[i]，利用树状数组可以在$O(logn)$的时间得到

算法的总体时间复杂度$O(nlogn)$

```c++
class Solution {
private:
    static const int MAXN = 50010;
    struct Node{
        int val, pos;
        bool operator<(const Node node){
            return val < node.val;
        }
    }temp[MAXN]; 
    int n, a[MAXN], t[MAXN];

public:
    int reversePairs(vector<int>& nums) {
        n = nums.size();
        for (int i = 0; i < n; i++){
            temp[i] = {nums[i], i+1};		 //a[]的下标从1开始
        }
        sort(temp, temp + n);
        for (int i = 0; i < n; i++){
            if (i == 0 || temp[i].val != temp[i-1].val)
                a[temp[i].pos] = i+1;
            else
                a[temp[i].pos] = a[temp[i-1].pos];
        }
        int res = 0;
        for (int i = 1; i <= n; i++){
            res += getSum(n) - getSum(a[i]);  //统计a[i]左侧>a[i]的元素个数
            //对于nums[i]而言，前面>nums[i]的元素可以和nums[i]构成逆序对
            update(a[i], 1);
        }
        return res;
    }

    int lowbit(int x){
        return x & -x;
    }

    void update(int x, int v){
        for (int i = x; i <= n; i += lowbit(i))
            t[i] += v;
    }

    int getSum(int x){
        int sum = 0;
        for (int i = x; i > 0; i -= lowbit(i))
            sum += t[i];
        return sum;
    }
};
```



1. 区域和检索 - 数组可修改 题目描述：给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 
2. 计算右侧小于当前元素的个数 题目描述：给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。
3. 翻转对 题目描述：给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。你需要返回给定数组中的重要翻转对的数量。
4. Range Sum Query - Mutable 题目描述：给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。同时支持对数组中的某个元素进行修改。
5. 区间和的个数 题目描述：给定一个整数数组 nums ，求出区间和的个数其中，满足左侧下标 i ≤ j ≤ k 且 nums[i] + nums[j] + nums[k] = 0。



#### 3.3.3 分桶法和平方分割

[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 **k**个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
>
> 你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
>
> **示例 1:**
>
> ```
> 输入: [3,2,1,5,6,4], k = 2
> 输出: 5
> ```
>
> **示例 2:**
>
> ```
> 输入: [3,2,3,1,2,4,5,5,6], k = 4
> 输出: 4
> ```
>
> **提示：**
>
> - $1 <= k <= nums.length <= 10^5$
> - $-10^4 <= nums[i] <= 10^4$

（1）使用快速排序，时间复杂度O(n)

（2）使用分桶法（分块法）

分块法，将有序的元素分割成若干块，`nums = {1, 2, 4, 9, 12, 34, 56, 78, 87}`，可以分割成3块{1, 2, 4}、{9, 12, 34}、{56, 78, 87}。

**对于N个元素的有序序列来说，出最后一块之外，其余每块元素都应该为floor(sqrt(N))，于是块数为ceil(sqrt(N))，每块元素不超过floor(sqrt(N))**

对于暴力的做法需要O(n)的时间来插入和删除元素，使用分块可以降低时间复杂度。

`block[i]`表示第`i`块中元素的个数，`hashTable[i]`表示元素`i`出现的次数

想要查找数组中第k大或者第k小的元素

```c++
const int MAXN = 100010, sqrtN = 316;
    
for (int i : nums)
	block[i / sqrtN]++;	//对元素i进行分块，按照元素的大小分到i/sqrtN块中

int sum = 0, idx = 0;    //已经得到的有序元素的个数
while (sum + block[idx] < k){
    sum += block[idx];
}

//退出循环时有sum + block[idx] >=k，那么继续在idx块中进行查找
int num = idx * sqrtN;	//第idx块中的第一个数
while (sum + hash[num] < k){
    sum += hash[num++];
}

return num;			   //当hash[num] == 0时会继续累加到下一个hash[num]不为0的数	
```





### 4.4 常用技巧精选（二）

#### 4.4.1 栈的运用

[单调栈](https://www.acwing.com/problem/content/832/)

> 给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出−1。
>
> #### 输入格式
>
> 第一行包含整数 N，表示数列长度。
>
> 第二行包含N个整数，表示整数数列。
>
> #### 输出格式
>
> 共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。
>
> #### 数据范围
>
> $1≤N≤10^5$
> $1≤数列中元素≤10^9$
>
> #### 输入样例：
>
> ```
> 5
> 3 4 2 7 5
> ```
>
> #### 输出样例：
>
> ```
> -1 3 -1 2 2
> ```

（1）暴力

利用两个for循环进行查找，显然时间复杂度为$O(n^2)$

（2）单调栈

```c++
/*
* 单调栈
* 目标：寻找距离nums[i]左边最近且比nums[i]小的元素
* 对于nums[i]而言，如果它比之前的nums[j](0 <= j < i)要小或者相等，
* 那么对于之后[i+1...n-1]的元素, nums[j]肯定不会成为答案，可以将nums[j]从栈中删去
* 那么将所有这样的元素删去之后，栈中就是一个单调递增栈
* 
* 3 4 2 7 5
* (1) 栈空，res = -1，并将3入栈
* (2) 4 > 3，所以res = 3栈顶元素3就是目标元素，4入栈
* (3) 2 < 4，不满足单调递增栈的定义，那么将栈顶元素不断弹出，4、3弹出后栈空res = -1
* (4) 7 > 2，所以res = 2栈顶元素2就是目标元素，7入栈
* (5) 5 < 7，栈顶元素7出栈，5 > 2，那么2就是目标元素res = 2

* summary:
    单调递增栈，用来寻找nums[i]左边且距离nums[i]最近，且比nums[i]小的元素值
    同理，利用单调递增栈，可以找到nums[i]右边且距离nums[i]最近的最小元素值（从右往左遍历）
 
* 下面用来寻找距离nums[i]右边且离nums[i]最近的比nums[i]大的元素
* 利用一个单调递减栈
* 
* 3 4 2 7 5
* (1) 栈空，3直接入栈						   		-> stack = {3}
* (2) 4 > 3，不符合单调递减栈的规则，所以3出栈    	  -> stack = {4}
*  对于出栈的元素3而言是因为后面有比它更大的元素需要入栈，所以待入栈的那个元素就是比3大且距离3右边最近的元素
* (3) 2 < 4，满足单调递减栈的定义，2直接入栈           -> stack = {4, 2}
* (4) 7 > 2，不满足单调递减栈的定义，那么栈顶元素出栈，所以2和4右边且距离它最近的更大的元素是7   -> stack = {7}
* (5) 5 < 7，满足单调递减栈的定义，2直接入栈           -> stack = {7, 5}
* 所以3 4 2 7 5右边比它大的元素是：4 7 7 -1 -1
*
* 和单调递增栈寻找左边比它小的数不同，
* 对于单调递减栈是栈顶元素在出栈时确定右边比它更大的元素，
* 当所有的元素都入栈之后，在栈中未被弹出的元素就是不存在右边比他更大的元素
* 而单调递增栈，左边比他更小的元素就是栈顶元素，栈空时说明没有比它更小的元素

* summary:
    单调递减栈，用来寻找nums[i]右边距离nums[i]最近，且比nums[i]大的元素值
    同理，利用单调递减栈，可以找到nums[i]左边距离nums[i]最近，且比nums[i]大的元素值（从右往左遍历）
*/
```

**代码**

```c++
#include <iostream>
#include <stack>
using namespace std;

int main(){
    int n;
    cin >> n;
    stack<int> st;  //维护一个单调递增栈
    for (int i = 0; i < n; i++){
        int x;
        cin >> x
        while (st.size() && st.top() >= x)
            st.pop();
        st.empty() ? cout << "-1 " : cout << st.top() << " " << endl;
        st.push(x);
    }
    return 0;
}
```





**单调栈，通过自己定义一些规则，让栈内的元素满足一定的条件，来进行模拟** 

**单调递减栈： ①在一个数组中针对每一个元素从它右边寻找第一个比它大的元素**

​                         **②在一个数组中针对每一个元素从它左边寻找第一个比它大的元素（从后往前遍历**）

###### [每日温度](https://leetcode.cn/problems/daily-temperatures/)

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n, 0);
        stack<int> st;
        for (int i = 0; i < n; i++){
            while (st.size() && temperatures[i] > temperatures[st.top()]){
                //只有temperatures[i]比栈顶元素大时，才找到了下一个温度更高的位置
                int cur = st.top();
                st.pop();
                res[cur] = i - cur; 
                //栈顶元素出栈，因为计算的是几天后会出现更高的温度所以是i-cur
            }
            st.push(i); //元素入栈
        }
        return res;
    }
};
```



###### [链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

```c++
class Solution {
public:
    vector<int> nextLargerNodes(ListNode* head) {
        if (!head)  return {};
        int n = getLength(head);
        vector<int> res(n, 0);
        stack<pair<int, ListNode*>> st;
        for (int i = 0; i < n; i++){
            while (st.size() && head->val > st.top().second->val){
                int cur = st.top().first;
                st.pop();
                res[cur] = head->val;
            }
            st.push({i, head});
            head = head->next;
        }
        return res;
    }

    int getLength(ListNode* head){
        int len = 0;
        while (head){
            len++;
            head = head->next;
        }
        return len;
    }
};
```

**单调递增栈**	

**利用单调递减栈，可以很快找到>栈顶元素的元素**
**当前元素 > 栈顶元素**
	**说明已经找到了右边第一个 >栈顶元素**
	**根据单调栈的性质>栈顶元素的距离左边最近的元素位于栈顶的下一个位置**
	**在这里就需要判断，出栈后栈是否为空，如果出栈后栈空，说明左边没有比栈顶元素更大的值** 



###### [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

（1）利用两个单调递增栈来寻找边界

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int> left(n, -1), right(n, n);
        //left[i]表示heights[i]左边距离nums[i]最近且<nums[i]的位置
        //right[i]表示heights[i]右边距离nums[i]最近且<nums[i]的位置

        stack<int> st;
        for (int i = 0; i < n; i++){
            while (st.size() && heights[st.top()] >= heights[i])
                st.pop();
            left[i] = (st.empty() ? -1 : st.top());
            st.push(i);
        }
        while (st.size())   st.pop();

        for (int i = n-1; i >= 0; i--){
            while (st.size() && heights[st.top()] >= heights[i])
                st.pop();
            right[i] = (st.empty() ? n : st.top());
            st.push(i);
        }

        int res = 0;
        for (int i = 0; i < n; i++){
            // cout << left[i] << " " << right[i] << endl;
            //边界:(left[i]+1，right[i])
            res = max(res, (right[i] - left[i] - 1) * heights[i]);
        }

        return res;
    }
};
```

（2）利用一个单调栈

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size(), res = 0;
        stack<int> st;
        heights.push_back(0);
        for (int i = 0; i <= n; i++){
            while (st.size() && heights[st.top()] >= heights[i]){
                int cur = st.top();
                st.pop();
                if (st.empty())
                    res = max(res, i * heights[cur]);
                else
                    res = max(res, (i - st.top() - 1) * heights[cur]);
            }
            st.push(i);
        }
        return res;
    }
};
```

****



